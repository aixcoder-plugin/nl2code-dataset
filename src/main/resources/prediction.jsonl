{"task_id": 0, "raw_nl": "Take a collection of Strings and return a combined string as a comma separated list with 'and' between the final pair. For example: [a, b, c] to \"a, b and c\".", "signature": "public String collectionToCommaDelimitedString(List<String> coll)", "code": "public String collectionToCommaDelimitedString ( List < String > coll ) { \nif ( coll == null || coll . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nIterator < String > it = coll . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nsb . append ( it . next ( ) ) ; \nif ( it . hasNext ( ) ) { \nsb . append ( \", \" ) ; \n} \n} \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 1, "raw_nl": "Creates a padding string of a certain length", "signature": "public String createPadding(int length, char padChar)", "code": "public String createPadding ( int length , char padChar ) { \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; i < length ; i ++ ) { \nsb . append ( padChar ) ; \n} \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 2, "raw_nl": "Create and returns a HttpURLConnection connection to a webpage", "signature": "public HttpURLConnection createHttpConnection(URL url, int connectTimeout, Map<String, String> requestProperties)", "code": "public HttpURLConnection createHttpConnection ( URL url , int connectTimeout , Map < String , String > requestProperties ) throws IOException { \nHttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; \nconnection . setConnectTimeout ( connectTimeout ) ; \nconnection . setReadTimeout ( connectTimeout ) ; \nconnection . setRequestMethod ( \"POST\" ) ; \nconnection . setRequestProperty ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) ; \nconnection . setRequestProperty ( \"Content-Length\" , \"0\" ) ; \nconnection . setDoOutput ( true ) ; \nconnection . setDoInput ( true ) ; \nconnection . setUseCaches ( false ) ; \nconnection . setInstanceFollowRedirects ( true ) ; \nconnection . setRequestProperty ( \"Content-Language\" , \"en-US\" ) ; \nif ( requestProperties != null ) { \nfor ( Map . Entry < String , String > entry : requestProperties . entrySet ( ) ) { \nconnection . setRequestProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \nreturn connection ; \n} ", "end_by": "end_token"}
{"task_id": 3, "raw_nl": "Write content to the file. If file does not exist, it will create one.", "signature": "public void writeToFile(String content, String fileName)", "code": "public void writeToFile ( String content , String fileName ) throws IOException { \nif ( fileName == null ) { \nthrow new IllegalArgumentException ( \"File name can not be null\" ) ; \n} \nif ( fileName . isEmpty ( ) ) { \nthrow new IllegalArgumentException ( \"File name can not be empty\" ) ; \n} \nif ( content == null ) { \nthrow new IllegalArgumentException ( \"File content can not be null\" ) ; \n} \nif ( content . isEmpty ( ) ) { \nthrow new IllegalArgumentException ( \"File content can not be empty\" ) ; \n} \nFile file = new File ( fileName ) ; \nif ( ! file . exists ( ) ) { \nfile . createNewFile ( ) ; \n} \nFileWriter fileWriter = new FileWriter ( file ) ; \nfileWriter . write ( content ) ; \nfileWriter . close ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 4, "raw_nl": "Close Reader. If object is null it is ignored", "signature": "public void close(Reader reader)", "code": "public void close ( Reader reader ) { \nif ( reader != null ) { \ntry { \nreader . close ( ) ; \n} catch ( IOException e ) { \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 5, "raw_nl": "max() that works on three integers. Like many of the other max() functions in this class", "signature": "public float max(float a, float b, float c) ", "code": "public float max ( float a , float b , float c ) { \nfloat ma = a > b ? a : b ; \nfloat mb = b > c ? b : c ; \nreturn ma > mb ? ma : mb ; \n} ", "end_by": "end_token"}
{"task_id": 6, "raw_nl": "put a short value into a byte array with specific offset", "signature": "public void putShort(byte[] data, short value, int offset)", "code": "public void putShort ( byte [ ] data , short value , int offset ) { \ndata [ offset ] = ( byte ) ( ( value >>> 8 ) & 0xFF ) ; \ndata [ offset + 1 ] = ( byte ) ( ( value ) & 0xFF ) ; \n} ", "end_by": "end_token"}
{"task_id": 7, "raw_nl": "\u4ece http \u670d\u52a1\u62c9\u53d6\u914d\u7f6e\u6587\u4ef6\u5e76\u89e3\u6790\u4e3aProperties \u5bf9\u8c61", "signature": "public Properties getProperties(String url)", "code": "public Properties getProperties ( String url ) { \nProperties properties = new Properties ( ) ; \ntry { \nproperties . load ( new URL ( url ) . openStream ( ) ) ; \n} catch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn properties ; \n} ", "end_by": "end_token"}
{"task_id": 8, "raw_nl": "\u7ed9\u4e00\u4e2a\u6570\u7ec4\uff0c\u627e\u51fa\u6700\u5927\u503c\u5e76\u4e14\u8fd4\u56de\u3002", "signature": "public int findMaxNumber(int[] nums)", "code": "public int findMaxNumber ( int [ ] nums ) { \nif ( nums == null || nums . length == 0 ) { \nreturn 0 ; \n} \nint maxNumber = nums [ 0 ] ; \nfor ( int i = 1 ; i < nums . length ; i ++ ) { \nif ( nums [ i ] > maxNumber ) { \nmaxNumber = nums [ i ] ; \n} \n} \nreturn maxNumber ; \n} ", "end_by": "end_token"}
{"task_id": 9, "raw_nl": "\u5c06 Date \u7c7b\u578b\u8f6c\u4e3a\u65f6\u95f4\u5b57\u7b26\u4e32\uff0c\u683c\u5f0f\u4e3a format", "signature": "public String date2String(final Date date, final DateFormat format)", "code": "public String date2String ( final Date date , final DateFormat format ) { \nif ( format != null ) { \nreturn format . format ( date ) ; \n} else { \nreturn EMPTY ; \n} \n} ", "end_by": "end_token"}
{"task_id": 10, "raw_nl": "Looks through the backups directory and assembles a list of all json backup files found. ", "signature": "public List<String> getBackupFiles(String dir)", "code": "public List < String > getBackupFiles ( String dir ) { \nList < String > list = new ArrayList < String > ( ) ; \nFile [ ] files = new File ( dir ) . listFiles ( ) ; \nif ( files != null ) { \nfor ( File file : files ) { \nif ( file . getName ( ) . endsWith ( \".json\" ) ) { \nlist . add ( file . getName ( ) ) ; \n} \n} \n} \nreturn list ; \n} ", "end_by": "end_token"}
{"task_id": 11, "raw_nl": "Rearranges the elements of the specified subarray in random order.", "signature": "public void shuffle(int[] array)", "code": "public void shuffle ( int [ ] array ) { \nif ( array == null ) \nthrow new NullPointerException ( \"argument array is null\" ) ; \nint n = array . length ; \nfor ( int i = 0 ; i < n ; i ++ ) { \n// between i and n-1\nint r = i + uniform ( n - i ) ; \nint temp = array [ i ] ; \narray [ i ] = array [ r ] ; \narray [ r ] = temp ; \n} \n} ", "end_by": "end_token"}
{"task_id": 12, "raw_nl": "Retrieves the value by specified int index of the given List.", "signature": "public String getValue(List<String> list, int index)", "code": "public String getValue ( List < String > list , int index ) { \nif ( list == null || index < 0 || index >= list . size ( ) ) { \nreturn null ; \n} \nreturn list . get ( index ) ; \n} ", "end_by": "end_token"}
{"task_id": 13, "raw_nl": "Returns a string, consisting of given length random char from given alphabet. ", "signature": "public String randomString(int length, String alphabet)", "code": "public String randomString ( int length , String alphabet ) { \nif ( alphabet == null || alphabet . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"Alphabet must not be null or empty.\" ) ; \n} \nif ( length < 0 ) { \nthrow new IllegalArgumentException ( \"Length must not be negative.\" ) ; \n} \nif ( length > alphabet . length ( ) ) { \nthrow new IllegalArgumentException ( \"Length must not exceed alphabet length.\" ) ; \n} \nStringBuilder sb = new StringBuilder ( length ) ; \nfor ( int i = 0 ; i < length ; i ++ ) { \nsb . append ( alphabet . charAt ( nextInt ( alphabet . length ( ) ) ) ) ; \n} \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 14, "raw_nl": "\u75281\u5230n\u968f\u673a\u521d\u59cb\u5316\u4e8c\u7ef4\u6570\u7ec4", "signature": "public void init(int[][] arr, int n) ", "code": "public void init ( int [ ] [ ] arr , int n ) { \nif ( arr == null || arr . length == 0 || arr [ 0 ] . length == 0 ) { \nreturn ; \n} \nint [ ] [ ] dp = new int [ n ] [ n ] ; \nfor ( int i = 0 ; i < n ; i ++ ) { \nArrays . fill ( dp [ i ] , -1 ) ; \n} \nfor ( int i = 0 ; i < arr . length ; i ++ ) { \nfor ( int j = 0 ; j < arr [ 0 ] . length ; j ++ ) { \nif ( arr [ i ] [ j ] != -1 ) { \ndp [ i ] [ j ] = arr [ i ] [ j ] ; \n} \n} \n} \nfor ( int i = 0 ; i < n ; i ++ ) { \nfor ( int j = 0 ; j < n ; j ++ ) { \nif ( dp [ i ] [ j ] != -1 ) { \narr [ i ] [ j ] = dp [ i ] [ j ] ; \n} \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 15, "raw_nl": "Copy a file from source path to destination path", "signature": "public void copyFile(String sourcePath, String destPath)", "code": "public void copyFile ( String sourcePath , String destPath ) throws IOException { \nPath source = Paths . get ( sourcePath ) ; \nPath dest = Paths . get ( destPath ) ; \nFiles . copy ( source , dest , StandardCopyOption . REPLACE_EXISTING ) ; \n} ", "end_by": "end_token"}
{"task_id": 16, "raw_nl": "Get a hashCode for the real vector. All NaN values have the same hash code.", "signature": "public int hashCode(double[] vector)", "code": "public int hashCode ( double [ ] vector ) { \nif ( isNaN ( vector ) ) { \nreturn 9 ; \n} \nint h = 1 ; \nfor ( double aVector : vector ) { \nh = 31 * h + ( int ) ( aVector + 0.5 ) ; \n} \nreturn h ; \n} ", "end_by": "end_token"}
{"task_id": 17, "raw_nl": "Parses character set name to Charset object", "signature": "public Charset charsetForName(String charsetName)", "code": "public Charset charsetForName ( String charsetName ) { \nif ( charsetName == null ) { \nreturn null ; \n} \ntry { \nreturn Charset . forName ( charsetName ) ; \n} catch ( Exception e ) { \nreturn null ; \n} \n} ", "end_by": "end_token"}
{"task_id": 18, "raw_nl": "Reads up to len bytes of data from this input stream into an array of bytes", "signature": "public byte[] readBytes(java.io.InputStream in, int len)", "code": "public byte [ ] readBytes ( java . io . InputStream in , int len ) throws java . io . IOException { \nif ( in == null ) \nreturn null ; \nint i = 0 ; \nint available = available ( ) ; \nif ( available < len ) { \nlen = available ; \n} \nbyte [ ] buf = new byte [ len ] ; \nif ( available > 0 ) { \ni = in . read ( buf , 0 , available ) ; \nif ( i > 0 ) { \nthis . count += i ; \n} \n} \nreturn buf ; \n} ", "end_by": "end_token"}
{"task_id": 19, "raw_nl": "Parses query string to Map from an url.", "signature": "public Map<String, String> parseQueryString(String queryString)", "code": "public Map < String , String > parseQueryString ( String queryString ) { \nMap < String , String > map = new HashMap < > ( ) ; \nif ( queryString != null ) { \nString [ ] parameters = queryString . split ( \"&\" ) ; \nfor ( String parameter : parameters ) { \nString [ ] keyValue = parameter . split ( \"=\" ) ; \nmap . put ( keyValue [ 0 ] , keyValue . length > 1 ? keyValue [ 1 ] : null ) ; \n} \n} \nreturn map ; \n} ", "end_by": "end_token"}
{"task_id": 20, "raw_nl": "Returns the value of an array by index, or null if the array has no value at that index.", "signature": "public Object get(Object[] array, int index)", "code": "public Object get ( Object [ ] array , int index ) { \nif ( array == null ) { \nreturn null ; \n} \nObject value = array [ index ] ; \nif ( value == null ) { \nvalue = JSONObject . NULL ; \n} \nreturn value ; \n} ", "end_by": "end_token"}
{"task_id": 21, "raw_nl": "Set the additional (undeclared) property with the specified name and value. If the property does not already exist, create it otherwise replace it.", "signature": "public void putAdditionalProperty(String key, Object value, Map<String, Object> additionalProperties)", "code": "public void putAdditionalProperty ( String key , Object value , Map < String , Object > additionalProperties ) { \nif ( value instanceof JsonElement ) { \nvalue = ( ( JsonElement ) value ) . getAsJsonObject ( ) ; \n} \nif ( additionalProperties == null ) { \nadditionalProperties = new HashMap < String , Object > ( ) ; \n} \nadditionalProperties . put ( key , value ) ; \n} ", "end_by": "end_token"}
{"task_id": 22, "raw_nl": "Read the base64 encoded image data from a JPEG image.", "signature": "public String readImageData(String filename)", "code": "public String readImageData ( String filename ) throws IOException { \nFileInputStream fis = new FileInputStream ( filename ) ; \nbyte [ ] data = new byte [ fis . available ( ) ] ; \nfis . read ( data ) ; \nfis . close ( ) ; \nreturn Base64 . encode ( data ) ; \n} ", "end_by": "end_token"}
{"task_id": 23, "raw_nl": "Returns the distance for the two given point", "signature": "public float distance(float x0, float y0, float x1, float y1)", "code": "public float distance ( float x0 , float y0 , float x1 , float y1 ) { \nfloat dx = x1 - x0 ; \nfloat dy = y1 - y0 ; \nreturn ( float ) Math . sqrt ( dx * dx + dy * dy ) ; \n} ", "end_by": "end_token"}
{"task_id": 24, "raw_nl": "Writes a collection of Strings to a File, overwriting any previous file contents. Each String is converted into a line in the File.", "signature": "public void writeFile(Collection<String> lines, File file)", "code": "public void writeFile ( Collection < String > lines , File file ) throws IOException { \nif ( file == null ) { \nthrow new IOException ( \"File is null\" ) ; \n} \nif ( file . isDirectory ( ) ) { \nthrow new IOException ( \"File is a directory\" ) ; \n} \nif ( ! file . getParentFile ( ) . exists ( ) ) { \nfile . getParentFile ( ) . mkdirs ( ) ; \n} \nif ( ! file . exists ( ) ) { \nfile . createNewFile ( ) ; \n} \ntry ( FileWriter fw = new FileWriter ( file ) ) { \nfor ( String line : lines ) { \nfw . write ( line ) ; \nfw . write ( \"\\n\" ) ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 25, "raw_nl": "Generate a hex string for the specified bytes.", "signature": "public final String toHex(byte[] byteArr)", "code": "public final String toHex ( byte [ ] byteArr ) { \nif ( byteArr == null ) \nreturn \"\" ; \nreturn toHex ( byteArr , byteArr . length ) ; \n} ", "end_by": "end_token"}
{"task_id": 26, "raw_nl": "\u83b7\u53d6\u76f8\u5e94\u6587\u4ef6filepath\u7684input stream", "signature": "public java.io.InputStream getInputStream(String filepath)", "code": "public java . io . InputStream getInputStream ( String filepath ) { \njava . io . InputStream is = null ; \ntry { \nis = new FileInputStream ( filepath ) ; \n} catch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \nreturn is ; \n} ", "end_by": "end_token"}
{"task_id": 27, "raw_nl": "\u83b7\u53d6\u7c7b\u4e0a\u5177\u6709\u6307\u5b9a\u6ce8\u89e3\u7684\u63a5\u53e3\u7684\u540d\u79f0\uff0c\u5982\u679c\u6709\u591a\u4e2a\uff0c\u5219\u4ee5\u7b2c\u4e00\u4e2a\u4e3a\u51c6 \u627e\u4e0d\u5230\u7b26\u5408\u6761\u4ef6\u7684\u63a5\u53e3\u5219\u8fd4\u56de clazz \u7c7b\u7684\u540d\u79f0", "signature": "public String getInterfaceName(Class<?> clazz, Class<? extends Annotation> annotation)", "code": "public String getInterfaceName ( Class < ? > clazz , Class < ? extends Annotation > annotation ) { \nif ( clazz == null ) { \nreturn null ; \n} \nString interfaceName = null ; \nClass < ? > [ ] interfaces = clazz . getInterfaces ( ) ; \nif ( interfaces == null || interfaces . length == 0 ) { \nreturn interfaceName ; \n} \nfor ( Class < ? > itfc : interfaces ) { \nif ( itfc . isAnnotationPresent ( annotation ) ) { \ninterfaceName = itfc . getName ( ) ; \n} \n} \nif ( interfaceName == null || interfaceName . length ( ) == 0 ) { \nreturn interfaceName ; \n} \nreturn interfaceName ; \n} ", "end_by": "end_token"}
{"task_id": 28, "raw_nl": "Split the given sequence with the given delimiter and return list of values.", "signature": "public java.util.List<String> split(String sequence, String delimiter)", "code": "public java . util . List < String > split ( String sequence , String delimiter ) { \njava . util . List < String > result = new ArrayList < String > ( ) ; \nint start = 0 ; \nint index = 0 ; \nwhile ( ( index = sequence . indexOf ( delimiter , start ) ) != -1 ) { \nresult . add ( sequence . substring ( start , index ) ) ; \nstart = index + delimiter . length ( ) ; \n} \nresult . add ( sequence . substring ( start ) ) ; \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 29, "raw_nl": "This returns the euclidean distance of two vectors sum(i=1,n) (q_i - p_i)^2", "signature": "public double euclideanDistance(double[] p, double[] q)", "code": "public double euclideanDistance ( double [ ] p , double [ ] q ) { \ndouble distance = 0 ; \nfor ( int i = 0 ; i < p . length ; i ++ ) { \ndistance += Math . pow ( ( p [ i ] - q [ i ] ) , 2 ) ; \n} \nreturn Math . sqrt ( distance ) ; \n} ", "end_by": "end_token"}
{"task_id": 30, "raw_nl": "Returns the entry associated with the specified key in map.", "signature": "public <K,V> Map.Entry<K, V> getEntry(Map<K,V> map, K key)", "code": "public < K , V > Map . Entry < K , V > getEntry ( Map < K , V > map , K key ) { \nif ( map == null || key == null ) { \nreturn null ; \n} \nint hash = hash ( key ) ; \nint i = indexFor ( hash , table . length ) ; \nfor ( Entry < K , V > e = table [ i ] ; e != null ; e = e . next ) { \nObject k ; \nif ( e . hash == hash && ( ( k = e . key ) == key || key . equals ( k ) ) ) { \nreturn e ; \n} \n} \nreturn null ; \n} ", "end_by": "end_token"}
{"task_id": 31, "raw_nl": "Returns the index of the first occurrence of the specified element in this list, returns -1 if the element is not found", "signature": "public int indexOf(int[] array, int element) ", "code": "public int indexOf ( int [ ] array , int element ) { \nif ( array == null ) { \nreturn -1 ; \n} \nfor ( int i = 0 ; i < array . length ; i ++ ) { \nif ( array [ i ] == element ) { \nreturn i ; \n} \n} \nreturn -1 ; \n} ", "end_by": "end_token"}
{"task_id": 32, "raw_nl": "Returns the minimum value in an array.", "signature": "public int min(int[] array)", "code": "public int min ( int [ ] array ) { \n// Validates input\nif ( array == null ) { \nthrow new IllegalArgumentException ( \"The Array must not be null\" ) ; \n} else if ( array . length == 0 ) { \nthrow new IllegalArgumentException ( \"Array cannot be empty.\" ) ; \n} \n// Finds and returns min\nint min = array [ 0 ] ; \nfor ( int j = 1 ; j < array . length ; j ++ ) { \nif ( array [ j ] < min ) { \nmin = array [ j ] ; \n} \n} \nreturn min ; \n} ", "end_by": "end_token"}
{"task_id": 33, "raw_nl": "Returns the sum of logarithms, which is Sum( Log(x[i]) ).", "signature": "public double logSum(double[] x)", "code": "public double logSum ( double [ ] x ) { \ndouble sum = 0.0 ; \nfor ( int i = 0 ; i < x . length ; i ++ ) { \nsum += Math . log ( x [ i ] ) ; \n} \nreturn sum ; \n} ", "end_by": "end_token"}
{"task_id": 34, "raw_nl": "Do a simple bubble sort to sort the server ids in ascending order.", "signature": "public void sortServers(int[] serverIds)", "code": "public void sortServers ( int [ ] serverIds ) { \nint size = serverIds . length ; \nint lowest ; \nfor ( int i = 0 ; i < size ; i ++ ) { \nlowest = i ; \nfor ( int j = i + 1 ; j < size ; j ++ ) { \nif ( serverIds [ j ] < serverIds [ lowest ] ) \nlowest = j ; \n} \nif ( lowest != i ) { \nint temp = serverIds [ i ] ; \nserverIds [ i ] = serverIds [ lowest ] ; \nserverIds [ lowest ] = temp ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 35, "raw_nl": "Ensure that an object reference passed as a parameter to the calling method is not null.", "signature": "public void ensureNotNull(Object obj)", "code": "public void ensureNotNull ( Object obj ) { \nif ( obj == null ) { \nthrow new IllegalArgumentException ( \"Object must not be null\" ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 36, "raw_nl": "Extract the filename from the given path.", "signature": "public String extractFileName(String path)", "code": "public String extractFileName ( String path ) { \nint lastSlashIndex = path . lastIndexOf ( '/' ) ; \nint lastDotIndex = path . lastIndexOf ( '.' ) ; \nif ( lastDotIndex > lastSlashIndex ) { \nlastSlashIndex = lastDotIndex ; \n} \nreturn path . substring ( lastSlashIndex + 1 ) ; \n} ", "end_by": "end_token"}
{"task_id": 37, "raw_nl": "Fill 1D matrix with random numbers.", "signature": "public void fillMatrix_1D(double[] m)", "code": "public void fillMatrix_1D ( double [ ] m ) { \nRandom r = new Random ( 2 ) ; \nfor ( int i = 0 ; i < m . length ; i ++ ) { \nm [ i ] = r . nextDouble ( ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 38, "raw_nl": "Find the occurence of the given key in the given array. Linear search, worst case running time is O(n).", "signature": "public int linearSearch(int[] arr, int key) ", "code": "public int linearSearch ( int [ ] arr , int key ) { \nfor ( int i = 0 ; i < arr . length ; i ++ ) { \nif ( arr [ i ] == key ) { \nreturn i ; \n} \n} \nreturn -1 ; \n} ", "end_by": "end_token"}
{"task_id": 39, "raw_nl": "Generate a not existing temporary file in specified dir.", "signature": "public String generateTempFile(String dir)", "code": "public String generateTempFile ( String dir ) { \nString fileName = generateTempFileName ( dir ) ; \nFile file = new File ( dir , fileName ) ; \nif ( ! file . exists ( ) ) { \ntry { \nfile . createNewFile ( ) ; \n} catch ( IOException e ) { \nthrow new RuntimeException ( \"Cannot create temporary file \" + fileName , e ) ; \n} \n} \nreturn file . getAbsolutePath ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 40, "raw_nl": "Get one character of index i from a given string buffer.", "signature": "public char getChar(StringBuffer sb, int i)", "code": "public char getChar ( StringBuffer sb , int i ) { \nif ( i < 0 || i >= sb . length ( ) ) { \nthrow new RuntimeException ( \"StringIndexOutOfBoundsException\" ) ; \n} \nreturn sb . charAt ( i ) ; \n} ", "end_by": "end_token"}
{"task_id": 41, "raw_nl": "\u5c06map\u4e2d\u6240\u6709\u7684key\u8f6c\u4e3a\u5927\u5199", "signature": "public Map<String, Object> getAllUpperCase(Map<String, Object> map)", "code": "public Map < String , Object > getAllUpperCase ( Map < String , Object > map ) { \nif ( map == null ) { \nreturn null ; \n} \nMap < String , Object > mapUpper = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { \nmapUpper . put ( toUpperCase ( entry . getKey ( ) ) , entry . getValue ( ) ) ; \n} \nreturn mapUpper ; \n} ", "end_by": "end_token"}
{"task_id": 42, "raw_nl": "\u5f97\u5230\u8ddd\u79bb\u5f53\u524d\u65f6\u95f4\u524d\u4e00\u5e74\u7684\u65f6\u95f4 @Title: getLastYearDate", "signature": "public String getLastYearDate()", "code": "public String getLastYearDate ( ) { \nint year = Calendar . getInstance ( ) . get ( Calendar . YEAR ) ; \nreturn year + \"\u5e74\u524d\" ; \n} ", "end_by": "end_token"}
{"task_id": 43, "raw_nl": "\u66f4\u65b0url\u4e2d\u7684\u53c2\u6570(\u4fdd\u8bc1\u53c2\u6570\u4e0d\u91cd\u590d)", "signature": "public String updateUrl(String url, String key, String value)", "code": "public String updateUrl ( String url , String key , String value ) { \nMap < String , String > map = new HashMap < > ( ) ; \nmap . put ( key , value ) ; \nreturn updateUrl ( url , map ) ; \n} ", "end_by": "end_token"}
{"task_id": 44, "raw_nl": "\u79fb\u9664 map \u4e2d\u7684 null \u6216\u8005 \u7a7a\u5b57\u7b26\u4e32", "signature": "public void removeNullValue(Map<String, Object> map)", "code": "public void removeNullValue ( Map < String , Object > map ) { \nSet < String > keySet = map . keySet ( ) ; \nfor ( String key : keySet ) { \nObject obj = map . get ( key ) ; \nif ( obj == null ) { \nmap . remove ( key ) ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 45, "raw_nl": "\u83b7\u53d6\u67d0\u4e2a\u65f6\u95f4data\u7684\u5e74\u4efd", "signature": "public int getYear(Date date)", "code": "public int getYear ( Date date ) { \nCalendar calendar = Calendar . getInstance ( ) ; \ncalendar . setTime ( date ) ; \nreturn calendar . get ( Calendar . YEAR ) ; \n} ", "end_by": "end_token"}
{"task_id": 46, "raw_nl": "Element-by-element matrix multiplication in place, A = A*B ", "signature": "public void matrixMultiply(double[][] A, double[][] B)", "code": "public void matrixMultiply ( double [ ] [ ] A , double [ ] [ ] B ) throws Exception { \ncheckMatrixDimensions ( A , B ) ; \nfor ( int i = 0 ; i < m ; i ++ ) { \nfor ( int j = 0 ; j < n ; j ++ ) { \nA [ i ] [ j ] = A [ i ] [ j ] * B [ i ] [ j ] ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 47, "raw_nl": "\u901a\u8fc7\u53cd\u5c04\u83b7\u53d6\u67d0\u4e2a\u7c7b\u7684\u5bf9\u8c61\u5185\u6240\u6709\u7684 public \u6210\u5458\u53d8\u91cf, \u5305\u62ec\u8be5\u7c7b\u7684\u57fa\u7c7b", "signature": "public List<Field> getFields(Class<?> clazz)", "code": "public List < Field > getFields ( Class < ? > clazz ) { \nif ( null == clazz ) { \nreturn null ; \n} \nList < Field > fields = new ArrayList < Field > ( ) ; \nfor ( Field field : clazz . getFields ( ) ) { \nfields . add ( field ) ; \n} \nreturn fields ; \n} ", "end_by": "end_token"}
{"task_id": 48, "raw_nl": "Adds all of the elements in collection to the Set.", "signature": "public void addAll(Set<Integer> set, Collection<Integer> collection)", "code": "public void addAll ( Set < Integer > set , Collection < Integer > collection ) { \nfor ( int i : collection ) { \nadd ( i ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 49, "raw_nl": "Helper function to convert a long number into a byte array (least significant byte first).", "signature": "public byte[] longToBytes(long x)", "code": "public byte [ ] longToBytes ( long x ) { \nbyte [ ] b = new byte [ 8 ] ; \nfor ( int i = 0 ; i < 8 ; i ++ ) { \nb [ i ] = ( byte ) x ; \nx >>>= 8 ; \n} \nreturn b ; \n} ", "end_by": "end_token"}
{"task_id": 50, "raw_nl": "\u5c06byte\u6570\u7ec4\u8f6c\u5316\u4e3a16\u8fdb\u5236\u5b57\u7b26\u4e32", "signature": "public String bytesToHexString(byte[] src)", "code": "public String bytesToHexString ( byte [ ] src ) { \nStringBuilder stringBuilder = new StringBuilder ( \"\" ) ; \nif ( src == null || src . length <= 0 ) { \nreturn null ; \n} \nfor ( int i = 0 ; i < src . length ; i ++ ) { \nint v = src [ i ] & 0xFF ; \nString hv = Integer . toHexString ( v ) ; \nif ( hv . length ( ) < 2 ) { \nstringBuilder . append ( 0 ) ; \n} \nstringBuilder . append ( hv ) ; \n} \nreturn stringBuilder . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 51, "raw_nl": "Returns a hash code value for this bit array.", "signature": "public int hashCode(byte[] byteArr)", "code": "public int hashCode ( byte [ ] byteArr ) { \nint hashCode = 0 ; \nfor ( int i = 0 ; i < repn . length ; i ++ ) hashCode = 31 * hashCode + repn [ i ] ; \nfor ( int i = 0 ; i < length ; i ++ ) hashCode = 31 * hashCode + ( byteArr [ i ] & 0xFF ) ; \nreturn hashCode ^ length ; \n} ", "end_by": "end_token"}
{"task_id": 52, "raw_nl": "Removes the entry with the specified key from this map if present.", "signature": "public void remove(Map<Integer, String> mapObj, Integer key)", "code": "public void remove ( Map < Integer , String > mapObj , Integer key ) { \nif ( mapObj == null || key == null ) { \nreturn ; \n} \nmapObj . remove ( key ) ; \n} ", "end_by": "end_token"}
{"task_id": 53, "raw_nl": "Convert a primitive input array into its object array version (e.g. from int[] to Integer[]).", "signature": "public Integer[] toObjectArray(int[] array)", "code": "public Integer [ ] toObjectArray ( int [ ] array ) { \nInteger [ ] result = new Integer [ array . length ] ; \nfor ( int i = 0 ; i < array . length ; i ++ ) { \nresult [ i ] = array [ i ] ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 55, "raw_nl": "\u5224\u65ad\u5b57\u7b26\u4e32\u662f\u5426\u53ea\u542b\u5b57\u6bcd\u548c\u6570\u5b57", "signature": "public boolean isLetterOrDigit(String str)", "code": "public boolean isLetterOrDigit ( String str ) { \nString regex = \"^[a-zA-Z0-9]+$\" ; \nreturn str . matches ( regex ) ; \n} ", "end_by": "end_token"}
{"task_id": 56, "raw_nl": "\u5224\u65ad\u662f\u5426\u53ea\u542b\u5b57\u6bcd", "signature": "public boolean isLetter(char c)", "code": "public boolean isLetter ( char c ) { \nif ( c > 'z' || c < 'a' ) { \nreturn false ; \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 57, "raw_nl": "Join 2 path elements if path separator not present at the end of first path element\uff0celse return the first element.", "signature": "public String joinPath(String path1, String path2)", "code": "public String joinPath ( String path1 , String path2 ) { \nif ( path1 . endsWith ( \"/\" ) && path2 . startsWith ( \"/\" ) ) { \nreturn path1 + path2 . substring ( 1 ) ; \n} else if ( path1 . endsWith ( \"/\" ) ) { \nreturn path1 + path2 ; \n} else if ( path2 . startsWith ( \"/\" ) ) { \nreturn path1 + path2 ; \n} else { \nreturn path1 + \"/\" + path2 ; \n} \n} ", "end_by": "end_token"}
{"task_id": 58, "raw_nl": "Converts an int into an array of byte using the default (little endian, Lsb0) byte and bit ordering.", "signature": "public byte[] intToByteArray(int value)", "code": "public byte [ ] intToByteArray ( int value ) { \nbyte [ ] src = new byte [ 4 ] ; \nsrc [ 0 ] = ( byte ) ( value & 0xff ) ; \nsrc [ 1 ] = ( byte ) ( ( value >> 8 ) & 0xff ) ; \nsrc [ 2 ] = ( byte ) ( ( value >> 16 ) & 0xff ) ; \nsrc [ 3 ] = ( byte ) ( ( value >> 24 ) & 0xff ) ; \nreturn src ; \n} ", "end_by": "end_token"}
{"task_id": 60, "raw_nl": "convert byte array to a hex string", "signature": "public String bytesToHex(byte[] bytes)", "code": "public String bytesToHex ( byte [ ] bytes ) { \nStringBuilder sbuf = new StringBuilder ( ) ; \nfor ( int idx = 0 ; idx < bytes . length ; idx ++ ) { \nint intVal = bytes [ idx ] & 0xff ; \nif ( intVal < 0x10 ) \nsbuf . append ( \"0\" ) ; \nsbuf . append ( Integer . toHexString ( intVal ) . toUpperCase ( ) ) ; \n} \nreturn sbuf . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 62, "raw_nl": "Calculates combinatorial number C(n,m). ", "signature": "public int combinatorial(int n, int m)", "code": "public int combinatorial ( int n , int m ) { \nint result = 1 ; \nint i = n ; \nint j = m ; \nwhile ( i > 0 || j > 0 ) { \nif ( i > 0 ) { \nresult *= i ; \ni -- ; \n} \nif ( j > 0 ) { \nresult *= j ; \nj -- ; \n} \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 63, "raw_nl": "\u68c0\u9a8c\u7528\u6237\u540d\u662f\u5426\u5408\u6cd5\uff0c\u53ea\u80fd\u5305\u62eca-z,A-Z,0-9\u548c\u4e0b\u5212\u7ebf_\uff0c\u4e0d\u80fd\u4ee5\u4e0b\u5212\u7ebf\u7ed3\u5c3e \u7528\u6237\u540d\u6709\u6700\u5c0f\u957f\u5ea6\u548c\u6700\u5927\u957f\u5ea6\u9650\u5236\uff0c\u6bd4\u5982\u7528\u6237\u540d\u5fc5\u987b\u662f4-20\u4f4d", "signature": "public boolean checkUsername(String username)", "code": "public boolean checkUsername ( String username ) { \nif ( username . length ( ) > 20 ) { \nreturn false ; \n} \nif ( username . length ( ) < 4 || username . length ( ) > 10 ) { \nreturn false ; \n} \nif ( ! username . matches ( \"[a-zA-Z0-9_]+\" ) ) { \nreturn false ; \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 64, "raw_nl": "\u5f97\u5230\u73b0\u5728\u65f6\u95f4", "signature": "public String getStringToday(String format)", "code": "public String getStringToday ( String format ) { \nDate currentTime = new Date ( ) ; \nSimpleDateFormat formatter = new SimpleDateFormat ( format ) ; \nString dateString = formatter . format ( currentTime ) ; \nreturn dateString ; \n} ", "end_by": "end_token"}
{"task_id": 65, "raw_nl": "return the last day of the date's month of specified string value in format: yyyy-MM", "signature": "public Date getMonthLastDay(String dateString)", "code": "public Date getMonthLastDay ( String dateString ) { \nSimpleDateFormat simpleDateFormat = new SimpleDateFormat ( \"yyyy-MM\" ) ; \nDate date = null ; \ntry { \ndate = simpleDateFormat . parse ( dateString ) ; \n} catch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nCalendar calendar = Calendar . getInstance ( ) ; \nif ( date != null ) { \ncalendar . setTime ( date ) ; \n} \ncalendar . add ( Calendar . MONTH , 1 ) ; \ncalendar . add ( Calendar . DAY_OF_MONTH , -1 ) ; \nreturn calendar . getTime ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 86, "raw_nl": "Returns true if the collection contains an element for the key.", "signature": "public boolean containsKey(Collection<String> collection, String key)", "code": "public boolean containsKey ( Collection < String > collection , String key ) { \nfor ( String value : collection ) { \nif ( value . equals ( key ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} ", "end_by": "end_token"}
{"task_id": 87, "raw_nl": "Returns true if the given object is an instance of the class or interface specified.", "signature": "public boolean isInstanceOf(Object object, Class<?> type)", "code": "public boolean isInstanceOf ( Object object , Class < ? > type ) { \nif ( object == null ) { \nreturn false ; \n} \nif ( type . isInstance ( object ) ) { \nreturn true ; \n} \nif ( object instanceof String ) { \nreturn type . isAssignableFrom ( object . getClass ( ) ) ; \n} \nreturn false ; \n} ", "end_by": "end_token"}
{"task_id": 88, "raw_nl": "\u5c0616\u8fdb\u5236\u5b57\u7b26\u4e32\u8f6c10\u8fdb\u5236", "signature": "public int hexStringToInt(String hexString)", "code": "public int hexStringToInt ( String hexString ) { \nint result = 0 ; \nint index = 0 ; \nint n = 0 ; \nint b = 0 ; \nfor ( int i = 0 ; i < hexString . length ( ) ; i ++ ) { \nindex = i % 2 ; \nn = Integer . valueOf ( hexString . substring ( i , i + 1 ) , 16 ) ; \nb = Integer . valueOf ( hexString . substring ( i + 1 , i + 2 ) , 16 ) ; \nresult += ( b << index * 4 ) ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 89, "raw_nl": "Add two integers, checking for overflow.", "signature": "public boolean checkOverflow(int x, int y)", "code": "public boolean checkOverflow ( int x , int y ) { \nlong m = ( ( long ) x ) + ( ( long ) y ) ; \nif ( m < Integer . MIN_VALUE || m > Integer . MAX_VALUE ) { \nreturn false ; \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 90, "raw_nl": "Add the value to the HashSet given by map.get(key), creating a new HashSet if the HashSet is null", "signature": "public void addToSet(Map<String, HashSet<Integer>> map, String key, Integer value)", "code": "public void addToSet ( Map < String , HashSet < Integer > > map , String key , Integer value ) { \nif ( map == null ) { \nreturn ; \n} \nif ( ! map . containsKey ( key ) ) { \nmap . put ( key , new HashSet < > ( ) ) ; \n} \nmap . get ( key ) . add ( value ) ; \n} ", "end_by": "end_token"}
{"task_id": 91, "raw_nl": "Calculate and return the average of the two values rounded DOWN.", "signature": "public int average(int a, int b)", "code": "public int average ( int a , int b ) { \nint c = a + b - ( ( a & b ) << 1 ) ; \nif ( // uh oh\nc < 0 ) \nc += 0x1000000 ; \nreturn c ; \n} ", "end_by": "end_token"}
{"task_id": 92, "raw_nl": "Check if #MIN_VALUE <= value <= #MAX_VALUE and if not an IllegalArgumentException is thrown.", "signature": "public void checkRange(int value, int min, int max)", "code": "public void checkRange ( int value , int min , int max ) { \nif ( ( value < min ) || ( value > max ) ) { \nthrow new IllegalArgumentException ( \"Value is out of range : \" + value ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 66, "raw_nl": "Merges the given two lists to a new list, but eliminating duplicates elements.", "signature": "public <T> ArrayList<T> merge(ArrayList<T> list1, ArrayList<T> list2)", "code": "public < T > ArrayList < T > merge ( ArrayList < T > list1 , ArrayList < T > list2 ) { \nArrayList < T > result = new ArrayList < T > ( ) ; \n// Keep track of the range of elements that we need to add.\nint range1 = 0 ; \nint range2 = 0 ; \n// Iterate through the first list.\nwhile ( range1 < list1 . size ( ) && range2 < list2 . size ( ) ) { \nT elem1 = list1 . get ( range1 ) ; \nT elem2 = list2 . get ( range2 ) ; \nint cmp = elem1 . compareTo ( elem2 ) ; \nif ( cmp < 0 ) { \n// We know list1 is sorted so we can add elem1 at the front.\nresult . add ( elem1 ) ; \nrange1 ++ ; \n} else if ( cmp > 0 ) { \n// We know list2 is sorted so we can add elem2 at the front.\nresult . add ( elem2 ) ; \nrange2 ++ ; \n} else { \n// We don't know how to merge so just add elem1 and elem2 at the end.\nresult . add ( elem2 ) ; \nrange2 ++ ; \n} \n} \n// Add any elements left in the first list.\nwhile ( range1 < list1 . size ( ) ) { \nresult . add ( list1 . get ( range1 ) ) ; \nrange1 ++ ; \n} \n// Add any elements left in the second list.\nwhile ( range2 < list2 . size ( ) ) { \nresult . add ( list2 . get ( range2 ) ) ; \nrange2 ++ ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 93, "raw_nl": "Check whether the String is a valid Java number", "signature": "public boolean isNumber(String str)", "code": "public boolean isNumber ( String str ) \nif ( StringUtils . isEmpty ( str ) ) { \nreturn false ; \n} \nchar [ ] chars = str . toCharArray ( ) ; \nint sz = chars . length ; \nboolean hasExp = false ; \nboolean hasDecPoint = false ; \nboolean allowSigns = false ; \nboolean foundDigit = false ; \n// deal with any possible sign up front\nint start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; \nif ( sz > start + 1 ) { \nif ( chars [ start ] == '0' && chars [ start + 1 ] == 'x' ) { \nint i = start + 2 ; \nif ( i == sz ) { \nreturn false ; \n} \n// checking hex (it can't be anything else)\nfor ( ; i < chars . length ; i ++ ) { \nch = chars [ i ] ; \nif ( ( ch < '0' || ch > '9' ) && ( ch < 'a' || ch > 'f' ) && ( ch < 'A' || ch > 'F' ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n// don't want to loop to the last char, check it afterwords\nsz -- ; \n// for type qualifiers\nint i = start ; \n// make a valid number (e.g. chars[0..5] = \"1234E\")\nwhile ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { \nif ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { \nfoundDigit = true ; \nallowSigns = false ; \n} else if ( chars [ i ] == '.' ) { \nif ( hasDecPoint || hasExp ) { \n// two decimal points or dec in exponent\nreturn false ; \n} \nhasDecPoint = true ; \n} else if ( chars [ i ] == 'e' || chars [ i ] == ", "end_by": "max_len"}
{"task_id": 94, "raw_nl": "Choose a pseudo-random element from the specified array.", "signature": "public int random(int[] array)", "code": "public int random ( int [ ] array ) { \nint index = random . nextInt ( array . length ) ; \nreturn array [ index ] ; \n} ", "end_by": "end_token"}
{"task_id": 95, "raw_nl": "Compare two java objects for equality.", "signature": "public boolean equals(Object o1, Object o2)", "code": "public boolean equals ( Object o1 , Object o2 ) \nif ( o1 == o2 ) { \nreturn true ; \n} \n/ If not equal, maybe one of the objects is null.\nif ( o1 == null || o2 == null ) { \nreturn false ; \n} \n// If the objects are the same, then they are the same.\nif ( o1 == o2 ) { \nreturn true ; \n} \n// If the objects are different, then they are not the same.\nif ( ! ( o1 instanceof java . lang . String ) ) { \nreturn false ; \n} \nif ( ! ( o2 instanceof java . lang . String ) ) { \nreturn false ; \n} \n// If the objects are the same, then they are the same.\nreturn o1 . equals ( o2 ) ; \n} ", "end_by": "end_token"}
{"task_id": 96, "raw_nl": "Compute the product of this matrix and the given column vector.", "signature": "public double[] product(double[] columnVector,double[][] matrix)", "code": "public double [ ] product ( double [ ] columnVector , double [ ] [ ] matrix ) { \nif ( columnVector . length != matrix . length ) { \nthrow new IllegalArgumentException ( \"vector length and matrix length do not match\" ) ; \n} \ndouble [ ] product = new double [ matrix [ 0 ] . length ] ; \nfor ( int i = 0 ; i < product . length ; i ++ ) { \nproduct [ i ] = 0 ; \nfor ( int j = 0 ; j < product . length ; j ++ ) { \nproduct [ i ] += matrix [ i ] [ j ] * columnVector [ j ] ; \n} \n} \nreturn product ; \n} ", "end_by": "end_token"}
{"task_id": 97, "raw_nl": "Concatenate two arrays of T type", "signature": "public <T> T[] concat(T[] a, T[] b)", "code": "public < T > T [ ] concat ( T [ ] a , T [ ] b ) { \nT [ ] c = Arrays . copyOf ( a , a . length + b . length ) ; \nSystem . arraycopy ( b , 0 , c , a . length , b . length ) ; \nreturn c ; \n} ", "end_by": "end_token"}
{"task_id": 98, "raw_nl": "Convert the text '&' mnemonic string to text string. The '&' symbol is treated as the mnemonic pointer. The double \"&&\" symbols are treated as the single '&'. For example the string \"&Look && Feel\" is converted to \"Look & Feel\".", "signature": "public String convertMnemonicString(String text)", "code": "public String convertMnemonicString ( String text ) { \nStringBuilder buf = new StringBuilder ( ) ; \nint prevIndex = 0 ; \nint nextIndex = text . indexOf ( '&' ) ; \nint len = text . length ( ) ; \nwhile ( nextIndex != -1 ) { \nString s = text . substring ( prevIndex , nextIndex ) ; \nbuf . append ( s ) ; \nnextIndex ++ ; \nif ( nextIndex != len && text . charAt ( nextIndex ) == '&' ) { \nbuf . append ( '&' ) ; \nnextIndex ++ ; \n} \nprevIndex = nextIndex ; \nnextIndex = text . indexOf ( '&' , nextIndex + 1 ) ; \n} \nbuf . append ( text . substring ( prevIndex , text . length ( ) ) ) ; \nreturn buf . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 99, "raw_nl": "Convert a boolean value into a string.", "signature": "public String boolToString(boolean b)", "code": "public String boolToString ( boolean b ) { \nif ( b ) { \nreturn \"true\" ; \n} else { \nreturn \"false\" ; \n} \n} ", "end_by": "end_token"}
{"task_id": 100, "raw_nl": "Convert an arbitrary text encoding to its canonical name.", "signature": "public String canonicalEncodingName(String encoding)", "code": "public String canonicalEncodingName ( String encoding ) { \nif ( encoding == null ) { \nreturn null ; \n} \ntry { \nreturn Charset . forName ( encoding ) . name ( ) ; \n} catch ( IllegalCharsetNameException icne ) { \nreturn encoding ; \n} catch ( UnsupportedCharsetException uce ) { \nreturn encoding ; \n} \n} ", "end_by": "end_token"}
{"task_id": 101, "raw_nl": "Create a copy of the Integer array.", "signature": "public int[] copy(int[] arr)", "code": "public int [ ] copy ( int [ ] arr ) { \nif ( arr == null ) { \nreturn null ; \n} \nint [ ] copy = new int [ arr . length ] ; \nfor ( int i = 0 ; i < arr . length ; i ++ ) { \ncopy [ i ] = arr [ i ] ; \n} \nreturn copy ; \n} ", "end_by": "end_token"}
{"task_id": 102, "raw_nl": "Returns the current number of entries in the map.", "signature": "public int size(Map<String, String> map)", "code": "public int size ( Map < String , String > map ) { \nint total = 0 ; \nfor ( Map . Entry < String , String > entry : map . entrySet ( ) ) { \ntotal += entry . getValue ( ) . length ( ) ; \n} \nreturn total ; \n} ", "end_by": "end_token"}
{"task_id": 103, "raw_nl": "Returns true if two doubles are considered equal. Tests if the absolute difference between the two doubles has a difference less then a given double (epsilon)Returns true if two doubles are considered equal. Tests if the absolute difference between the two doubles has a difference less then a given double (epsilon)", "signature": "public boolean equals(double a, double b, double epsilon)", "code": "public boolean equals ( double a , double b , double epsilon ) { \nif ( Math . abs ( a - b ) <= epsilon ) \nreturn true ; \nreturn false ; \n} ", "end_by": "end_token"}
{"task_id": 104, "raw_nl": "Puts a byte and a short into this byte vector. The byte vector is automatically enlarged if necessary.", "signature": "public void putShort(byte[] data, byte b, short s)", "code": "public void putShort ( byte [ ] data , byte b , short s ) { \nint length = this . length ; \nif ( length + 2 > data . length ) { \nenlarge ( 2 ) ; \n} \nbyte [ ] data = this . data ; \ndata [ length ++ ] = b ; \ndata [ length ++ ] = ( byte ) ( s >>> 8 ) ; \ndata [ length ++ ] = ( byte ) s ; \nthis . length = length ; \n} ", "end_by": "end_token"}
{"task_id": 105, "raw_nl": "Advances the iterator either forward or backward the specified number of steps. Negative values move backward, and positive values move forward. This is equivalent to repeatedly calling next() or previous().", "signature": "public int next(Iterator<Integer> iterator, int n)", "code": "public int next ( Iterator < Integer > iterator , int n ) { \nint result = 0 ; \nwhile ( iterator . hasNext ( ) ) { \nint i = iterator . next ( ) ; \nif ( i < 0 ) { \nresult = i + n ; \ncontinue ; \n} \nresult = i ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 106, "raw_nl": "\u4e00\u7ef4\u6570\u7ec4\u8f6c\u4e3a\u4e8c\u7ef4\u6570\u7ec4", "signature": "public int[][] arrayToMatrix(int[] m, int width, int height)", "code": "public int [ ] [ ] arrayToMatrix ( int [ ] m , int width , int height ) { \nint [ ] [ ] result = new int [ height ] [ width ] ; \nfor ( int i = 0 ; i < height ; i ++ ) { \nfor ( int j = 0 ; j < width ; j ++ ) { \nint p = j * height + i ; \nresult [ i ] [ j ] = m [ p ] ; \n} \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 107, "raw_nl": "Verifies that the given array is not null or empty.", "signature": "public boolean checkNotNullOrEmpty(int[] array)", "code": "public boolean checkNotNullOrEmpty ( int [ ] array ) { \nif ( array == null ) { \nreturn false ; \n} \nreturn array . length != 0 ; \n} ", "end_by": "end_token"}
{"task_id": 108, "raw_nl": "Removes all white spaces from a string A whitespace is identified using the Java method Character.isWhiteSpace", "signature": "public String removeAllWhiteSpaces(String str)", "code": "public String removeAllWhiteSpaces ( String str ) { \nif ( str == null ) { \nreturn null ; \n} \nint sz = str . length ( ) ; \nStringBuilder buffer = new StringBuilder ( sz ) ; \nboolean space = false ; \nfor ( int i = 0 ; i < sz ; i ++ ) { \nchar ch = str . charAt ( i ) ; \nif ( Character . isWhitespace ( ch ) ) { \nbuffer . append ( ch ) ; \nspace = true ; \n} else if ( space ) { \nbuffer . append ( ' ' ) ; \nspace = false ; \n} \n} \nreturn buffer . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 109, "raw_nl": "subtract b from a", "signature": "public String[] sub(String[] a, String[] b)", "code": "public String [ ] sub ( String [ ] a , String [ ] b ) { \nString [ ] c = new String [ a . length ] ; \nfor ( int i = 0 ; i < a . length ; i ++ ) { \nc [ i ] = sub ( a [ i ] , b [ i ] ) ; \n} \nreturn c ; \n} ", "end_by": "end_token"}
{"task_id": 110, "raw_nl": "Converts the string argument into a float value.", "signature": "public float parseFloat(String floatStr)", "code": "public float parseFloat ( String floatStr ) { \njava . lang . Float floatValue = new java . lang . Float ( floatStr ) ; \nreturn floatValue . floatValue ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 111, "raw_nl": "Return true if the local path is a Windows absolute path.", "signature": "private boolean isWindowsAbsolutePath(String path)", "code": "private boolean isWindowsAbsolutePath ( String path ) \nif ( ! isAbsolutePath ( path ) ) \nreturn false ; \n// On Windows, an absolute path starts with \"[drive_letter]:\\\".\n/ If it is not, it has to be relative to the server current directory.\nString localPath = System . getProperty ( \"user.dir\" ) ; \nString serverPath = System . getProperty ( \"server.dir\" ) ; \nString newPath = path . substring ( 2 ) ; \nif ( newPath . length ( ) > 0 ) { \nnewPath = newPath . substring ( 1 ) ; \n} \nreturn localPath . startsWith ( \"\\\\\\\\\" ) && localPath . indexOf ( serverPath ) == -1 && ! newPath . startsWith ( \"\\\\\\\\\" ) ; \n} ", "end_by": "end_token"}
{"task_id": 112, "raw_nl": "Calculates the distance between two points in high-dimensional space.", "signature": "public double length(double[] p0, double[] p1)", "code": "public double length ( double [ ] p0 , double [ ] p1 ) { \ndouble sum = 0 ; \nfor ( int i = 0 ; i < p0 . length ; i ++ ) { \ndouble d = p0 [ i ] - p1 [ i ] ; \nsum += d * d ; \n} \nreturn Math . sqrt ( sum ) ; \n} ", "end_by": "end_token"}
{"task_id": 113, "raw_nl": "This function takes an array of words, and returns a string with all the words in the separated by a space.", "signature": "public String getStringfromStringArray(String[] array)", "code": "public String getStringfromStringArray ( String [ ] array ) { \nString s = \"\" ; \nfor ( int i = 0 ; i < array . length ; i ++ ) { \ns += array [ i ] + \" \" ; \n} \nreturn s ; \n} ", "end_by": "end_token"}
{"task_id": 114, "raw_nl": "Check whether a file is actually a valid zip", "signature": "public boolean isValidZip(File zip)", "code": "public boolean isValidZip ( File zip ) { \ntry { \nZipFile zipFile = new ZipFile ( zip ) ; \nzipFile . close ( ) ; \nreturn true ; \n} catch ( IOException e ) { \nreturn false ; \n} \n} ", "end_by": "end_token"}
{"task_id": 115, "raw_nl": "Parse a list of longs into strings.", "signature": "public String[] toTimestampStrs(long[] timestamps)", "code": "public String [ ] toTimestampStrs ( long [ ] timestamps ) { \nif ( timestamps == null ) { \nreturn null ; \n} \nString [ ] result = new String [ timestamps . length ] ; \nfor ( int i = 0 ; i < timestamps . length ; ++ i ) { \nresult [ i ] = Long . toString ( timestamps [ i ] ) ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 116, "raw_nl": "Change the size of this array. Content between indexes 0 and min(size(), newSize) will be preserved.", "signature": "public void resize(int[] arr,long newSize)", "code": "public void resize ( int [ ] arr , long newSize ) { \nfinal int numPages = numPages ( newSize ) ; \nif ( numPages > pages . length ) { \npages = Arrays . copyOf ( pages , ArrayUtil . oversize ( numPages , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) ; \n} \nfor ( int i = numPages -1 ; i >= 0 && pages [ i ] == null ; -- i ) { \npages [ i ] = newIntPage ( i ) ; \n} \nfor ( int i = numPages ; i < pages . length && pages [ i ] != null ; ++ i ) { \npages [ i ] = null ; \nreleasePage ( i ) ; \n} \nthis . size = newSize ; \n} ", "end_by": "end_token"}
{"task_id": 117, "raw_nl": "\u6982\u8ff0\uff1a\u622a\u53d6\u6307\u5b9a\u957f\u5ea6\u7684\u6570\u7ec4", "signature": "public byte[] subBytes(byte[] src, int pos, int count)", "code": "public byte [ ] subBytes ( byte [ ] src , int pos , int count ) { \nbyte [ ] dest = new byte [ count ] ; \nSystem . arraycopy ( src , pos , dest , 0 , count ) ; \nreturn dest ; \n} ", "end_by": "end_token"}
{"task_id": 118, "raw_nl": "\u8fd4\u56de\u4e0d\u5c0f\u4e8e\u8f93\u5165\u503cvalue\u7684\u6700\u5c0f\u6574\u6570", "signature": "public int floor(double val)", "code": "public int floor ( double val ) { \nint i = ( int ) val ; \nreturn val < i ? i -1 : i ; \n} ", "end_by": "end_token"}
{"task_id": 119, "raw_nl": "\u4fdd\u7559\u4e24\u4f4d\u5c0f\u6570", "signature": "public String formatDouble(double val)", "code": "public String formatDouble ( double val ) { \nDecimalFormat df = new DecimalFormat ( \"#.00\" ) ; \nreturn df . format ( val ) ; \n} ", "end_by": "end_token"}
{"task_id": 120, "raw_nl": "Compares the two specified double values,return 1 if the first value is greater than the second value,-1 if the first value is less than the second value,0 if the two values are equal. There are two special cases: Double.NaN is equal to Double.NaN and it is greater than any other double value, including Double.POSITIVE_INFINITY; +0.0d is greater than -0.0d", "signature": "public int compare(double double1, double double2)", "code": "public int compare ( double double1 , double double2 ) { \nif ( double1 < double2 ) { \nreturn -1 ; \n} else if ( double1 > double2 ) { \nreturn 1 ; \n} else { \nreturn 0 ; \n} \n} ", "end_by": "end_token"}
{"task_id": 121, "raw_nl": "Get the index of the next slash.", "signature": "public int getNextSlash(String path, int index)", "code": "public int getNextSlash ( String path , int index ) { \nint nextSlash = path . indexOf ( '/' , index + 1 ) ; \nif ( nextSlash == -1 || nextSlash == path . length ( ) -1 ) { \nreturn -1 ; \n} \nreturn nextSlash ; \n} ", "end_by": "end_token"}
{"task_id": 122, "raw_nl": "Returns true if all entries of (all subarrays of) the input array are >= 0. Returns true if the array is non-null, but empty", "signature": "public boolean isNonNegative(long[][] in)", "code": "public boolean isNonNegative ( long [ ] [ ] in ) { \nfor ( int i = 0 ; i < in . length ; i ++ ) { \nfor ( int j = 0 ; j < in [ i ] . length ; j ++ ) { \nif ( in [ i ] [ j ] < 0 ) { \nreturn false ; \n} \n} \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 123, "raw_nl": "Returns maximum possible integer, less or equal than oldValue, divisible by quantum.", "signature": "public int floor(int x, int quantum)", "code": "public int floor ( int x , int quantum ) { \nif ( x < 0 ) \nthrow new IllegalArgumentException ( \"Negative input to floor()\" ) ; \nif ( quantum == 0 || x == 0 ) \nreturn 0 ; \nif ( x < 1 ) \nreturn x ; \nint qfloor = floor ( x ) ; \nif ( qfloor < 0 ) \nreturn qfloor -1 ; \nif ( qfloor == 0 ) \nreturn 0 ; \nif ( qfloor == 1 ) \nreturn 1 ; \nif ( x - qfloor < quantum ) \nreturn qfloor -1 ; \nreturn qfloor ; \n} ", "end_by": "end_token"}
{"task_id": 124, "raw_nl": "Appends an item to the list.", "signature": "public void append(List<String> list, String item)", "code": "public void append ( List < String > list , String item ) { \nif ( list == null ) \nlist = new ArrayList < String > ( ) ; \nlist . add ( item ) ; \n} ", "end_by": "end_token"}
{"task_id": 125, "raw_nl": "\u5224\u65ad\u67d0\u4e2a\u65e5\u671f\u5c5e\u4e8e\u672c\u6708\u7684\u7b2c\u51e0\u5929", "signature": "public int getDaysByMonth(String dateTime)", "code": "public int getDaysByMonth ( String dateTime ) { \nCalendar cal = Calendar . getInstance ( ) ; \ncal . setTime ( parse ( dateTime ) ) ; \nreturn cal . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; \n} ", "end_by": "end_token"}
{"task_id": 67, "raw_nl": "Multiplies the vector by the transpose of the given matrix.", "signature": "public double[] multiplyTranspose(double[] vector, double[][] matrix)", "code": "public double [ ] multiplyTranspose ( double [ ] vector , double [ ] [ ] matrix ) { \ndouble [ ] result = new double [ vector . length ] ; \nfor ( int i = 0 ; i < vector . length ; i ++ ) { \nresult [ i ] = 0 ; \nfor ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { \nresult [ i ] += vector [ j ] * matrix [ i ] [ j ] ; \n} \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 68, "raw_nl": "Removes and returns last element in list, return null if empty.", "signature": "public String removeLast(ArrayList<String> list)", "code": "public String removeLast ( ArrayList < String > list ) { \nif ( list . size ( ) == 0 ) \nreturn null ; \nreturn list . remove ( list . size ( ) -1 ) ; \n} ", "end_by": "end_token"}
{"task_id": 69, "raw_nl": "Returns the largest value in linked list.", "signature": "public int getMax(LinkedList<Integer> list)", "code": "public int getMax ( LinkedList < Integer > list ) { \nint max = list . getLast ( ) ; \nint temp = 0 ; \nwhile ( list . size ( ) > 1 ) { \ntemp = list . get ( list . size ( ) -2 ) ; \nlist . remove ( list . size ( ) -1 ) ; \nlist . add ( temp ) ; \n} \nreturn max ; \n} ", "end_by": "end_token"}
{"task_id": 70, "raw_nl": "Calculate the elapsed time between two times specified in milliseconds.", "signature": "public long elapsedTime(Calendar start, Calendar end)", "code": "public long elapsedTime ( Calendar start , Calendar end ) { \nif ( start == null || end == null ) { \nthrow new IllegalArgumentException ( \"The dates must not be null\" ) ; \n} \nlong startMs = start . getTimeInMillis ( ) ; \nlong endMs = end . getTimeInMillis ( ) ; \nreturn ( endMs - startMs ) ; \n} ", "end_by": "end_token"}
{"task_id": 71, "raw_nl": "Compute the CRC32 of an array of bytes.", "signature": "public long crc32(byte[] bytes)", "code": "public long crc32 ( byte [ ] bytes ) { \nCrc32 crc = new Crc32 ( ) ; \ncrc . update ( bytes ) ; \nreturn crc . getValue ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 72, "raw_nl": "Create an instance of a clazz using the current thread context ClassLoader.", "signature": "public <T> T newInstance(Class<T> clazz)", "code": "public < T > T newInstance ( Class < T > clazz ) { \ntry { \nreturn clazz . newInstance ( ) ; \n} catch ( InstantiationException e ) { \nthrow new RuntimeException ( e ) ; \n} catch ( IllegalAccessException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 73, "raw_nl": "Delete data from start until end index (end inclusive) of a object List.", "signature": "public <T> void delete(List<T> list, int start, int end) ", "code": "public < T > void delete ( List < T > list , int start , int end ) { \nif ( list == null ) \nreturn ; \nif ( start < 0 || end < 0 || start > end || end > list . size ( ) ) \nreturn ; \nif ( start == end ) { \nlist . clear ( ) ; \nreturn ; \n} \nif ( end == list . size ( ) ) { \nint s = start ; \nstart = end -1 ; \nend = s ; \n} \nT [ ] arr = list . toArray ( ( T [ ] ) new Object [ list . size ( ) - ( end - start ) ] ) ; \nint i = 0 ; \nfor ( ; i < arr . length ; i ++ ) { \nif ( i >= start && i < end ) \narr [ i ] = arr [ i + 1 ] ; \n} \nlist . clear ( ) ; \nfor ( T t : arr ) list . add ( t ) ; \n} ", "end_by": "end_token"}
{"task_id": 126, "raw_nl": "Unzip the contents of the given zip in the given directory (create it if it doesn't exist)", "signature": "public void unzip(String zipPath, String destDirPath)", "code": "public void unzip ( String zipPath , String destDirPath ) throws IOException { \nInputStream zipIn = new FileInputStream ( zipPath ) ; \nbyte [ ] buf = new byte [ 8192 ] ; \nFile destDir = new File ( destDirPath ) ; \nString canonicalDestDirPath = destDir . getCanonicalPath ( ) ; \nZipInputStream zis = new ZipInputStream ( zipIn ) ; \nFileOutputStream fos = null ; \ntry { \nZipEntry zEntry ; \nwhile ( ( zEntry = zis . getNextEntry ( ) ) != null ) { \n// if it is empty directory, create it\nif ( zEntry . isDirectory ( ) ) { \nnew File ( destDir , zEntry . getName ( ) ) . mkdirs ( ) ; \ncontinue ; \n} \n// if it is a file, extract it\nString filePath = getZipEntryFileName ( destDir , zEntry , canonicalDestDirPath ) ; \nint lastSeparator = filePath . lastIndexOf ( \"/\" ) ; \nString fileDir = \"\" ; \nif ( lastSeparator >= 0 ) { \nfileDir = filePath . substring ( 0 , lastSeparator ) ; \n} \n// create directory for a file\nnew File ( destDir , fileDir ) . mkdirs ( ) ; \n// write file\nFile outFile = new File ( destDir , filePath ) ; \nfos = new FileOutputStream ( outFile ) ; \nint n = 0 ; \nwhile ( ( n = zis . read ( buf ) ) >= 0 ) { \nfos . write ( buf , 0 , n ) ; \n} \nfos . close ( ) ; \n} \n} catch ( IOException ioe ) { \nif ( fos != null ) { \ntry { \nfos . close ( ) ; \n} catch ( IOException ioe2 ) { \n} \n} \n} finally { \ntry { \nzipIn . close ( ) ; \nif ( zis != null ) \nzis . close ( ) ; \n} catch ( IOException ioe ) { \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 75, "raw_nl": "Get the number of days for the given month in the given year.", "signature": "public int getDaysInMonth(int year, int month)", "code": "public int getDaysInMonth ( int year , int month ) \n/ return 0; // replace this line with your solution\nint [ ] [ ] array = { { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } , { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } , { 31 , 30 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } , { 31 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 30 , 31 } , { 31 , 30 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 30 , 31 } , { 31 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 30 , 31 , 30 , 31 } } ; \nint [ ] [ ] array2 = { { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 } , { 15 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 } , { 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 } , { 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 } , { 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 } , { 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 } , { 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 } , { ", "end_by": "max_len"}
{"task_id": 76, "raw_nl": "\u5f97\u5230filepath\u8def\u5f84\u4e0b\u7b2c\u4e00\u5c42\u76ee\u5f55\u7ed3\u6784\u4e2d\u6240\u6709\u7684class\u6587\u4ef6", "signature": "public List<String> getClassFileNames(String filepath)", "code": "public List < String > getClassFileNames ( String filepath ) { \nList < String > fileNames = new ArrayList < String > ( ) ; \nFile file = new File ( filepath ) ; \nif ( file . exists ( ) ) { \nfileNames = getClassFileNames ( file ) ; \n} \nreturn fileNames ; \n} ", "end_by": "end_token"}
{"task_id": 78, "raw_nl": "\u7528str2\u66ff\u6362\u5b57\u7b26\u4e32str\u4e2d\u7b2c\u4e00\u4e2a\u51fa\u73b0\u7684str1", "signature": "public String replaceFirst(String str, String str1, String str2) ", "code": "public String replaceFirst ( String str , String str1 , String str2 ) \nif ( str == null || str1 == null || str2 == null ) { \nreturn null ; \n} \nif ( str . indexOf ( str1 ) == -1 ) { \nreturn str ; \n} \nindex = str . indexOf ( str1 ) ; \nif ( index == -1 ) { \nreturn str ; \n} \nint len = str . length ( ) ; \nStringBuffer sb = new StringBuffer ( len ) ; \nsb . append ( str . substring ( 0 , index ) ) ; \nsb . append ( str2 ) ; \nsb . append ( str . substring ( index + str1 . length ( ) , len ) ) ; \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 79, "raw_nl": "Writes certain bytes from the specified byte array starting from an offset to this output stream.", "signature": "public void write(byte[] b, int off, int len, OutputStream outputStream)", "code": "public void write ( byte [ ] b , int off , int len , OutputStream outputStream ) IOException { \nif ( b == null ) { \nthrow new NullPointerException ( ) ; \n( off < 0 || len < 0 || off + len > b . length ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nreturn ; \n} \nif ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} \nfor ( int i = 0 ; i < len ; i ++ ) { \nwrite ( b [ off + i ] ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 80, "raw_nl": "\u968f\u673a\u751f\u6210[origin, bound)\u8303\u56f4\u4e4b\u5185\u7684\u4e00\u4e2aint\u503c", "signature": "public int randomInt(int origin, int bound)", "code": "public int randomInt ( int origin , int bound ) { \nif ( origin >= bound ) { \nthrow new IllegalArgumentException ( \"bound must be greater than origin\" ) ; \n} \nreturn ( int ) ( origin + ( ( bound - origin ) * Math . random ( ) ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 81, "raw_nl": "\u4e0a\u4f20\u4e00\u4e2a\u6587\u4ef6filename\u81f3\u6307\u5b9a\u8def\u5f84pathname\u4e0b", "signature": "public void uploadFile(String pathname, String filename)", "code": "public void uploadFile ( String pathname , String filename ) { \ntry { \nclient . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; \nclient . storeFile ( pathname + \"/\" + filename , new File ( pathname ) ) ; \nSystem . out . println ( \"\u4e0a\u4f20\u6210\u529f\" ) ; \n} catch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 82, "raw_nl": "Debug helper function that returns the diff of two property maps, only displaying the key that is different and in which map it exists compared to the other map,example:map:key1,key2 map2:key1,key2,key3", "signature": "public String diff(java.util.Map<String, String> map1, java.util.Map<String, String> map2) ", "code": "public String diff ( java . util . Map < String , String > map1 , java . util . Map < String , String > map2 ) { \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"=== PropertyMap diff ===\\n\" ) ; \nsb . append ( \"PropertyMap map1:\\n\" ) ; \nsb . append ( map1 . toString ( ) ) ; \nsb . append ( \"PropertyMap map2:\\n\" ) ; \nsb . append ( map2 . toString ( ) ) ; \nsb . append ( \"\\n\" ) ; \nsb . append ( \"PropertyMap diff:\\n\" ) ; \nsb . append ( \"map1 size: \" + map1 . size ( ) + \"\\n\" ) ; \nsb . append ( \"map2 size: \" + map2 . size ( ) + \"\\n\" ) ; \nsb . append ( \"map1 keys: \" + map1 . keySet ( ) + \"\\n\" ) ; \nsb . append ( \"map2 keys: \" + map2 . keySet ( ) + \"\\n\" ) ; \nsb . append ( \"map1 values: \" + map1 . values ( ) + \"\\n\" ) ; \nsb . append ( \"map2 values: \" + map2 . values ( ) + \"\\n\" ) ; \nsb . append ( \"\\n\" ) ; \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 83, "raw_nl": "Returns a new, immutable collection containing the names of all entities within the directory denoted by the current path", "signature": "public List<String> getFiles(String dir)", "code": "public List < String > getFiles ( String dir ) { \nList < String > list = new ArrayList < String > ( ) ; \nFile file = new File ( dir ) ; \nif ( ! file . exists ( ) ) { \nreturn list ; \n} \nFile [ ] files = file . listFiles ( ) ; \nif ( files == null ) { \nreturn list ; \n} \nfor ( File f : files ) { \nif ( f . isFile ( ) ) { \nlist . add ( f . getName ( ) ) ; \n} \n} \nreturn list ; \n} ", "end_by": "end_token"}
{"task_id": 84, "raw_nl": "Rotate this a two-dimensional point around Y axis with the given angle in radians.", "signature": "public Point rotateY(double angle, Point point)", "code": "public Point rotateY ( double angle , Point point ) { \ndouble x = point . x - this . x ; \ndouble y = point . y - this . y ; \ndouble cos = Math . cos ( angle ) ; \ndouble sin = Math . sin ( angle ) ; \nthis . x = x * cos - y * sin ; \nthis . y = x * sin + y * cos ; \nreturn this ; \n} ", "end_by": "end_token"}
{"task_id": 85, "raw_nl": "If the string passed in is not blank or null and did not end with the trailing value, then appended the trailing value to it and return the result ", "signature": "public String appendTrailing(String str, String trailing)", "code": "public String appendTrailing ( String str , String trailing ) { \nif ( str == null || str . isEmpty ( ) ) { \nreturn null ; \n} \nif ( isEmpty ( trailing ) ) { \nreturn trailing ; \n} \nif ( isEmpty ( ) ) { \nreturn str ; \n} \nif ( str . endsWith ( \"\\n\" ) ) { \nreturn str + trailing ; \n} \nif ( str . endsWith ( \"\\r\" ) ) { \nreturn str . concat ( trailing ) ; \n} \nreturn str + \"\\n\" + trailing ; \n} ", "end_by": "end_token"}
{"task_id": 127, "raw_nl": "returns a array including given range. [start, end)", "signature": "public int[] range(int start, int end)", "code": "public int [ ] range ( int start , int end ) { \nint [ ] result = new int [ end - start + 1 ] ; \nint index = 0 ; \nfor ( int i = start ; i <= end ; i ++ ) { \nresult [ index ] = i ; \nindex ++ ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 128, "raw_nl": "Clear the given calendar, setting to zero all time values less than or equal to that of the given field. For example, clearing to Calendar#HOUR will floor the time to nearest hour which occurred before or at the given time (e.g., 1:32 --> 1:30).", "signature": "public Calendar clearTo(Calendar c, int field)", "code": "public Calendar clearTo ( Calendar c , int field ) { \nint i = indexOf ( c , field ) ; \nif ( i == -1 ) { \nthrow new IllegalArgumentException ( \"Invalid field \" + field ) ; \n} \nc . clear ( field ) ; \nif ( field == Calendar . DAY_OF_MONTH ) { \nc . set ( Calendar . DAY_OF_MONTH , 1 ) ; \n} \nif ( field == Calendar . MONTH ) { \nc . set ( Calendar . MONTH , 0 ) ; \n} \nif ( field == Calendar . YEAR ) { \nc . set ( Calendar . YEAR , 0 ) ; \n} \nif ( field == Calendar . HOUR_OF_DAY ) { \nc . clear ( Calendar . HOUR_OF_DAY ) ; \n} \nif ( field == Calendar . MINUTE ) { \nc . clear ( Calendar . MINUTE ) ; \n} \nif ( field == Calendar . SECOND ) { \nc . clear ( Calendar . SECOND ) ; \n} \nif ( field == Calendar . MILLISECOND ) { \nc . clear ( Calendar . MILLISECOND ) ; \n} \nreturn c ; \n} ", "end_by": "end_token"}
{"task_id": 129, "raw_nl": "\u83b7\u53d6\u5f53\u524d\u7cfb\u7edf\u65f6\u95f4 minute\u5206\u949f\u540e \u7684\u65f6\u95f4", "signature": "public String getNowDate(int minute)", "code": "public String getNowDate ( int minute ) { \nCalendar cal = Calendar . getInstance ( ) ; \ncal . add ( Calendar . MINUTE , minute ) ; \nreturn new SimpleDateFormat ( \"yyyy-MM-dd HH:mm:ss\" ) . format ( cal . getTime ( ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 130, "raw_nl": "Check the given value is in int range.", "signature": "public boolean isDecimalWithinIntRange(BigDecimal decimalValue)", "code": "public boolean isDecimalWithinIntRange ( BigDecimal decimalValue ) \nif ( decimalValue == null ) { \nreturn false ; \n} \n( intMin != null && decimalValue . compareTo ( intMin ) < 0 ) { \nreturn false ; \n} \nif ( intMax != null && decimalValue . compareTo ( intMax ) > 0 ) { \nreturn false ; \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 131, "raw_nl": "Produces a new double array containing the elements between the start and end indices. The start index is inclusive, the end index exclusive. Null array input produces null output.", "signature": "public double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive)", "code": "public double [ ] subarray ( final double [ ] array , int startIndexInclusive , int endIndexExclusive ) { \nif ( array == null ) { \nreturn null ; \n} \nif ( startIndexInclusive < 0 ) { \nstartIndexInclusive = 0 ; \n} \nif ( endIndexExclusive > array . length ) { \nendIndexExclusive = array . length ; \n} \nfinal int newSize = endIndexExclusive - startIndexInclusive ; \nif ( newSize <= 0 ) { \nreturn EMPTY_DOUBLE_ARRAY ; \n} \nfinal double [ ] subarray = new double [ newSize ] ; \nSystem . arraycopy ( array , startIndexInclusive , subarray , 0 , newSize ) ; \nreturn subarray ; \n} ", "end_by": "end_token"}
{"task_id": 132, "raw_nl": "\u5c06\u5fae\u535a\u65f6\u95f4\u5b57\u7b26\u4e32\u8f6c\u6362\u6210yyyyMMddHHmmSS \u5fae\u535a\u65f6\u95f4\u5b57\u7b26\u4e32\u6709\uff1a xx\u5206\u949f\u524d \u4eca\u5929 11:53 07\u670809\u65e5 13:36 2010-09-23 19:55:38", "signature": "public String parseDate(String weiboTimeStr)", "code": "public String parseDate ( String weiboTimeStr ) { \n// \u5c06\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u65e5\u671f\nDate weiboDate = null ; \ntry { \nweiboDate = new SimpleDateFormat ( \"yyyy-MM-dd HH:mm:ss\" ) . parse ( weiboTimeStr ) ; \n} catch ( ParseException e ) { \ne . printStackTrace ( ) ; \n} \n// \u5c06\u65e5\u671f\u8f6c\u6362\u6210\u65f6\u95f4\nCalendar calendar = Calendar . getInstance ( ) ; \ncalendar . setTime ( weiboDate ) ; \n// \u5c06\u65f6\u95f4\u8f6c\u6362\u6210\u6beb\u79d2\nlong weiboTimeLong = calendar . getTimeInMillis ( ) ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u79d2\nlong weiboTimeSec = weiboTimeLong / 1000 ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u5206\u949f\nlong weiboTimeMin = weiboTimeLong / 60 ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u5c0f\u65f6\nlong weiboTimeHour = weiboTimeLong / 60 / 60 ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u5929\nlong weiboTimeDay = weiboTimeLong / 24 ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u6708\nlong weiboTimeMonth = weiboTimeLong / 30 ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u5e74\nlong weiboTimeYear = weiboTimeLong / 365 ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u5e74\u6708\u65e5\nString weiboTimeYearMonth = weiboTimeYear + \"\u5e74\" + ( weiboTimeMonth + 1 ) + \"\u6708\" ; \n// \u5fae\u535a\u65f6\u95f4\u8f6c\u6362\u6210\u5e74\u6708\u65e5\u65f6\u5206\u79d2\nString weiboTimeYearMonthDay = weiboTimeYear + \"\u5e74\" + weiboTimeMonth + \"\u6708\" + weiboTimeDay + \"\u65e5\" ; \nreturn weiboTimeYearMonth + \"\u5e74\" + weiboTimeMonth + \"\u6708", "end_by": "max_len"}
{"task_id": 133, "raw_nl": "\u8fd4\u56de\u5f53\u6708\u5f00\u59cb\u65f6\u95f4", "signature": "public long currentMonthStartUnixTime()", "code": "public long currentMonthStartUnixTime ( ) { \nCalendar cal = Calendar . getInstance ( ) ; \ncal . set ( Calendar . DAY_OF_MONTH , 1 ) ; \ncal . set ( Calendar . HOUR_OF_DAY , 0 ) ; \ncal . set ( Calendar . MINUTE , 0 ) ; \ncal . set ( Calendar . SECOND , 0 ) ; \ncal . set ( Calendar . MILLISECOND , 0 ) ; \nreturn cal . getTimeInMillis ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 134, "raw_nl": "Multiply Long and Double numbers.", "signature": "public Long multiply(Long number, Double multiplier)", "code": "public Long multiply ( Long number , Double multiplier ) { \nif ( number == 0 || multiplier == 0 ) { \nreturn 0L ; \n} \ndouble bigNumber = Double . max ( Math . abs ( number ) , Math . abs ( multiplier ) ) ; \ndouble smallNumber = Double . min ( Math . abs ( number ) , Math . abs ( multiplier ) ) ; \ndouble maxMultiplier = Long . MAX_VALUE / bigNumber ; \nif ( smallNumber < maxMultiplier ) { \nreturn Long . valueOf ( number * multiplier ) . longValue ( ) ; \n} else { \nif ( ( number > 0 && multiplier < 0 ) || ( number < 0 && multiplier > 0 ) ) { \nreturn Long . MIN_VALUE ; \n} else { \nreturn Long . MAX_VALUE ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 135, "raw_nl": "Multiply two Short numbers.", "signature": "public Short multiply(Short a, Short b)", "code": "public Short multiply ( Short a , Short b ) { \nif ( a == 0 || b == 0 ) { \nreturn 0 ; \n} \nint bigNumber = Integer . max ( Math . abs ( a ) , Math . abs ( b ) ) ; \nint smallNumber = Integer . min ( Math . abs ( a ) , Math . abs ( b ) ) ; \nint maxMultiplier = Short . MAX_VALUE / bigNumber ; \nif ( smallNumber < maxMultiplier ) { \nreturn Integer . valueOf ( a * b ) . shortValue ( ) ; \n} else { \nif ( ( a > 0 && b < 0 ) || ( a < 0 && b > 0 ) ) { \nreturn Short . MIN_VALUE ; \n} else { \nreturn Short . MAX_VALUE ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 136, "raw_nl": "Attempt to find a field on the supplied Class with the supplied name and/or type. Searches all superclasses up to Object.", "signature": "public Field findField(Class clazz, String name, Class type)", "code": "public Field findField ( Class clazz , String name , Class type ) { \nif ( clazz == null ) { \nthrow new IllegalArgumentException ( \"Class must not be null\" ) ; \n} \nif ( name == null && type == null ) { \nthrow new IllegalArgumentException ( \"Either name or type of the field must be specified\" ) ; \n} \nClass searchType = clazz ; \nwhile ( ! Object . class . equals ( searchType ) && searchType != null ) { \nField [ ] fields = searchType . getDeclaredFields ( ) ; \nfor ( int i = 0 ; i < fields . length ; i ++ ) { \nField field = fields [ i ] ; \nif ( ( name == null || name . equals ( field . getName ( ) ) ) && ( type == null || type . equals ( field . getType ( ) ) ) ) { \nreturn field ; \n} \n} \nsearchType = searchType . getSuperclass ( ) ; \n} \nreturn null ; \n} ", "end_by": "end_token"}
{"task_id": 137, "raw_nl": "\u83b7\u53d6request\u7684IP\u5730\u5740", "signature": "public String getIPAddr(HttpRequest request)", "code": "", "end_by": "repeat_pattern"}
{"task_id": 138, "raw_nl": "Convert byte array to binary String", "signature": "public String toBinary(byte[] pBytes) ", "code": "public String toBinary ( byte [ ] pBytes ) { \nif ( pBytes == null ) { \nreturn null ; \n} \nreturn new String ( pBytes ) ; \n} ", "end_by": "end_token"}
{"task_id": 139, "raw_nl": "Convert arguments of a method (signature) to an array of Type objects.", "signature": "public Type[] getArgumentTypes(String signature)", "code": "public Type [ ] getArgumentTypes ( String signature ) { \nArrayList vec = new ArrayList ( ) ; \nint index ; \nType [ ] types ; \ntry { \n// Read all declarations between for `(' and `)'\nif ( signature . charAt ( 0 ) != '(' ) \nthrow new ClassFormatException ( \"Invalid method signature: \" + signature ) ; \n// current string position\nindex = 1 ; \nwhile ( signature . charAt ( index ) != ')' ) { \nvec . add ( getType ( signature . substring ( index ) ) ) ; \n// update position\nindex += consumed_chars ; \n} \n} catch ( StringIndexOutOfBoundsException e ) { \n// Should never occur\nthrow new ClassFormatException ( \"Invalid method signature: \" + signature ) ; \n} \ntypes = new Type [ vec . size ( ) ] ; \nvec . toArray ( types ) ; \nreturn types ; \n} ", "end_by": "end_token"}
{"task_id": 140, "raw_nl": "Convert a partial buffer to a String.", "signature": "public String toString(ByteBuffer buffer, int position, int length, Charset charset)", "code": "public String toString ( ByteBuffer buffer , int position , int length , Charset charset ) { \nif ( buffer == null ) \nreturn null ; \nif ( buffer . hasArray ( ) ) \nreturn new String ( buffer . array ( ) , buffer . arrayOffset ( ) + position , length , charset ) ; \nelse { \nbyte [ ] data = new byte [ length ] ; \nbuffer . get ( data ) ; \nreturn new String ( data , charset ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 141, "raw_nl": "\u4e24\u4e2a\u65f6\u95f4\u4e4b\u95f4\u76f8\u5dee\u8ddd\u79bb\u591a\u5c11\u5929,\u65f6\u95f4\u683c\u5f0fyyyy-MM-dd", "signature": "public long getDistanceDays(String str1, String str2)", "code": "public long getDistanceDays ( String str1 , String str2 ) { \nSimpleDateFormat df = new SimpleDateFormat ( \"yyyy-MM-dd\" ) ; \nlong day = 0 ; \ntry { \nDate start = df . parse ( str1 ) ; \nDate end = df . parse ( str2 ) ; \nlong time1 = start . getTime ( ) ; \nlong time2 = end . getTime ( ) ; \nlong diff ; \nif ( time1 < time2 ) { \ndiff = time2 - time1 ; \n} else { \ndiff = time1 - time2 ; \n} \nday = diff / ( 24 * 60 * 60 * 1000 ) ; \n} catch ( ParseException e ) { \ne . printStackTrace ( ) ; \n} \nreturn day ; \n} ", "end_by": "end_token"}
{"task_id": 142, "raw_nl": "\u83b7\u53d6url\u7684\u9876\u7ea7\u57df\u540d", "signature": "public String getTopDomain(String url)", "code": "public String getTopDomain ( String url ) { \nif ( url . contains ( \".\" ) ) { \nreturn url . substring ( 0 , url . lastIndexOf ( \".\" ) ) ; \n} \nreturn url ; \n} ", "end_by": "end_token"}
{"task_id": 143, "raw_nl": "Returns true if the given String matches to one of the provided Patterns, false otherwise.", "signature": "public boolean matchesPattern(String _string, Pattern[] _patterns)", "code": "public boolean matchesPattern ( String _string , Pattern [ ] _patterns ) { \nfor ( Pattern p : _patterns ) { \nif ( p . matcher ( _string ) . matches ( ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} ", "end_by": "end_token"}
{"task_id": 144, "raw_nl": "Extracts all the files in the given zip file to the input destination path. If zip file does not exist or destination path is invalid then an exception is thrown.", "signature": "public void extractAll(String destPath, String zipName)", "code": "public void extractAll ( String destPath , String zipName ) throws IOException { \nFile zipFile = new File ( zipName ) ; \nif ( zipFile . exists ( ) ) { \nif ( zipFile . isDirectory ( ) ) { \nString msg = \"Zip file [\" + zipName + \"] exists but is a directory\" ; \nthrow new IOException ( msg ) ; \n} \nif ( ! zipFile . canRead ( ) ) { \nString msg = \"Zip file [\" + zipName + \"] cannot be read\" ; \nthrow new IOException ( msg ) ; \n} \n} else { \nString msg = \"Zip file [\" + zipName + \"] does not exist\" ; \nthrow new IOException ( msg ) ; \n} \nEnumeration < ? extends ZipEntry > zipEntries = zipFile . entries ( ) ; \nwhile ( zipEntries . hasMoreElements ( ) ) { \nZipEntry entry = zipEntries . nextElement ( ) ; \nString entryName = entry . getName ( ) ; \nFile destFile = new File ( destPath , entryName ) ; \nif ( ! destFile . getParentFile ( ) . exists ( ) ) { \nString msg = \"Extracted file [\" + entryName + \"] does not exist or is not readable\" ; \nthrow new IOException ( msg ) ; \n} \nif ( ! destFile . getParentFile ( ) . isDirectory ( ) ) { \nString msg = \"Extracted file [\" + entryName + \"] is not a directory\" ; \nthrow new IOException ( msg ) ; \n} \nif ( ! destFile . getParentFile ( ) . canWrite ( ) ) { \nString msg = \"Extracted file [\" + entryName + \"] is not writable\" ; \nthrow new IOException ( msg ) ; \n} \nif ( entry . isDirectory ( ) ) { \nString msg = \"Extracted file [\" + entryName + \"] is", "end_by": "max_len"}
{"task_id": 145, "raw_nl": "\u5224\u65ad\u4e24\u4e2a\u6570\u7ec4\u7684\u5185\u5bb9\u662f\u5426\u76f8\u7b49 \u7528\u4e8eequals\u7684\u6bd4\u8f83", "signature": "public boolean equals(Object[] array, Object[] other)", "code": "public boolean equals ( Object [ ] array , Object [ ] other ) { \nint length = array . length ; \nif ( length != other . length ) { \nreturn false ; \n} \nfor ( int i = 0 ; i < length ; i ++ ) { \nif ( ! ( array [ i ] . equals ( other [ i ] ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 146, "raw_nl": "Returns a set with all unique methodNames of methods.", "signature": "public Set<String> getMethods(ClassLoader classLoader, String className)", "code": "public Set < String > getMethods ( ClassLoader classLoader , String className ) { \nif ( ! methods . containsKey ( className ) ) { \nmethods . put ( className , new HashSet < > ( ) ) ; \n} \nreturn methods . get ( className ) ; \n} ", "end_by": "end_token"}
{"task_id": 147, "raw_nl": "Returns the pid of the task", "signature": "String getPid(FutureTask t)", "code": "String getPid ( FutureTask t ) { \nif ( t != null ) { \nObject o = t . result ; \nif ( o != null ) { \nreturn o . toString ( ) ; \n} \n} \nreturn null ; \n} ", "end_by": "end_token"}
{"task_id": 148, "raw_nl": "Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)", "signature": "public <E> void swap(List<E> list, int i, int j)", "code": "public < E > void swap ( List < E > list , int i , int j ) { \ncheckPositionIndexes ( i , j , list . size ( ) ) ; \nE tmp = list . get ( i ) ; \nlist . set ( i , list . get ( j ) ) ; \nlist . set ( j , tmp ) ; \n} ", "end_by": "end_token"}
{"task_id": 149, "raw_nl": "Get the radian between current line(determined by point A and B) and horizontal line.", "signature": "public float getRadian(Point A, Point B)", "code": "public float getRadian ( Point A , Point B ) { \nif ( A == null || B == null ) { \nreturn 0 ; \n} \nfloat dx = B . x - A . x ; \nfloat dy = B . y - A . y ; \nreturn ( float ) Math . atan ( dy / dx ) ; \n} ", "end_by": "end_token"}
{"task_id": 151, "raw_nl": "Converts from an int array to an Integer array.", "signature": "public Integer[] asObjectArray(int[] array)", "code": "public Integer [ ] asObjectArray ( int [ ] array ) { \nInteger [ ] objectArray = new Integer [ array . length ] ; \nfor ( int i = 0 ; i < array . length ; i ++ ) objectArray [ i ] = array [ i ] ; \nreturn objectArray ; \n} ", "end_by": "end_token"}
{"task_id": 152, "raw_nl": "\u751f\u621032\u4f4d\u7684MD5\u7801", "signature": "public String toMd5Code(String str)", "code": "public String toMd5Code ( String str ) { \nString base = str + \"/\" + slat ; \nString md5 = DigestUtils . md5DigestAsHex ( base . getBytes ( ) ) ; \nreturn md5 ; \n} ", "end_by": "end_token"}
{"task_id": 153, "raw_nl": "\u8ba1\u7b97 C2 = M xor t", "signature": "public byte[] calculateC2(byte[] m, byte[] t)", "code": "public byte [ ] calculateC2 ( byte [ ] m , byte [ ] t ) { \nif ( t == null || t . length != 32 ) { \nthrow new IllegalArgumentException ( \"calculateC2 input parameter t invalid\" ) ; \n} \nif ( m == null || m . length != 32 ) { \nthrow new IllegalArgumentException ( \"calculateC2 input parameter m invalid\" ) ; \n} \nbyte [ ] result = new byte [ 32 ] ; \nfor ( int i = 0 ; i < 32 ; i ++ ) { \nresult [ i ] = ( byte ) ( m [ i ] ^ t [ i ] ) ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 154, "raw_nl": "\u83b7\u53d6\u8d44\u6e90\u6587\u4ef6\u7684url", "signature": "public URL getUrlFile(String fileName)", "code": "public URL getUrlFile ( String fileName ) { \nif ( StringUtil . isEmpty ( fileName ) ) { \nreturn null ; \n} \nreturn this . getClass ( ) . getClassLoader ( ) . getResource ( fileName ) ; \n} ", "end_by": "end_token"}
{"task_id": 156, "raw_nl": "Adds a given vector (array) to another one. * Every element of the second array (missing element is treated to be zero) is added to the corresponding element (if not missing) of the first array.", "signature": "public void addTo(float[] arrayA, float[] arrayB)", "code": "public void addTo ( float [ ] arrayA , float [ ] arrayB ) { \nif ( arrayA . length != arrayB . length ) \nthrow new RuntimeException ( \"The two arrays must have the same length!\" ) ; \nfor ( int i = 0 ; i < arrayA . length ; i ++ ) arrayA [ i ] += arrayB [ i ] ; \n} ", "end_by": "end_token"}
{"task_id": 157, "raw_nl": "Searches backward for value in a given array", "signature": "public int lastIndexOf(float value, float[] array)", "code": "public int lastIndexOf ( float value , float [ ] array ) { \nif ( value > array [ array . length -1 ] ) { \nreturn -1 ; \n} \nint index = -1 ; \nint i = ( int ) ( ( array . length -1 ) - value ) / 2 ; \nwhile ( i >= 0 ) { \nif ( array [ i ] == value ) { \nindex = i ; \nbreak ; \n} else if ( value > array [ i ] ) { \ni -- ; \n} else { \ni ++ ; \n} \n} \nreturn index ; \n} ", "end_by": "end_token"}
{"task_id": 160, "raw_nl": "\u968f\u673a\u62bd\u53d6\u6307\u5b9a\u6570\u91cf\u7684\u7528\u6237\uff0c\u4f5c\u4e3a\u4e2d\u5956\u7528\u6237", "signature": "public List<String> doDrawRandom(List<String> users, int count)", "code": "public List < String > doDrawRandom ( List < String > users , int count ) { \nList < String > result = new ArrayList < > ( ) ; \nfor ( int i = 0 ; i < count ; i ++ ) { \nresult . add ( users . get ( getRandom ( users . size ( ) ) ) ) ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 161, "raw_nl": "Returns the geometric center of this sequence of points", "signature": "public Point getCenter(List<Point> points)", "code": "public Point getCenter ( List < Point > points ) { \nint n = points . size ( ) ; \nif ( n < 1 ) { \nthrow new IllegalArgumentException ( \"must have at least 1 point\" ) ; \n} \ndouble x = 0 ; \ndouble y = 0 ; \nfor ( int i = 0 ; i < n ; i ++ ) { \nPoint p = points . get ( i ) ; \nx += p . getX ( ) ; \ny += p . getY ( ) ; \n} \nreturn new Point ( x / n , y / n ) ; \n} ", "end_by": "end_token"}
{"task_id": 162, "raw_nl": "\u62ec\u53f7\u5339\u914d\u68c0\u6d4b.", "signature": "public boolean checkbracket(String str)", "code": "public boolean checkbracket ( String str ) { \nStack < Character > stack = new Stack < > ( ) ; \nfor ( int i = 0 ; i < str . length ( ) ; i ++ ) { \nchar ch = str . charAt ( i ) ; \nif ( ch == '(' ) { \nstack . push ( ch ) ; \n} else if ( ch == ')' ) { \nif ( stack . isEmpty ( ) ) { \nreturn false ; \n} \nchar topChar = stack . pop ( ) ; \nif ( topChar != '(' ) { \nreturn false ; \n} \n} \n} \nreturn stack . isEmpty ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 163, "raw_nl": "Move a file or directory from source to destination, recursively copying subdirectories.", "signature": "public void move(Path src, Path dest)", "code": "public void move ( Path src , Path dest ) throws IOException { \nif ( ! fs . isDirectory ( src ) ) { \n// source is a file\nfs . rename ( src , dest ) ; \nreturn ; \n} \nif ( fs . isDirectory ( dest ) ) { \ndest = new Path ( dest , src . getName ( ) ) ; \n} \nFileStatus [ ] srcs = listStatus ( src ) ; \nif ( srcs . length == 0 ) { \nthrow new IOException ( \"Cannot rename empty directory: \" + src ) ; \n} \nif ( fs . isDirectory ( dest ) ) { \ndest = new Path ( dest , src . getName ( ) ) ; \n} \nif ( ! fs . mkdirs ( dest . getParent ( ) ) ) { \nthrow new IOException ( \"Cannot create directory: \" + dest . getParent ( ) ) ; \n} \nboolean succeeded = false ; \ntry { \nfor ( int i = 0 ; i < srcs . length ; i ++ ) { \nfs . rename ( srcs [ i ] . getPath ( ) , dest ) ; \nsucceeded = true ; \n} \n} finally { \nif ( ! succeeded ) { \n// remove the destination directory before copy in case of exception\nfs . delete ( dest , true ) ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 164, "raw_nl": "Reverse a Map into a ValueSetMap, where each original value is mapped to the set of all its original keys.", "signature": "public <K, V> Map<V, Set<K> > reverseMapIntoValueSetMap(Map<K, V> map)", "code": "public < K , V > Map < V , Set < K > > reverseMapIntoValueSetMap ( Map < K , V > map ) { \nMap < V , Set < K > > reverseMap = new HashMap < V , Set < K > > ( ) ; \nfor ( Map . Entry < K , V > entry : map . entrySet ( ) ) { \nSet < K > keys = reverseMap . get ( entry . getValue ( ) ) ; \nif ( keys == null ) { \nkeys = new HashSet < K > ( ) ; \nreverseMap . put ( entry . getValue ( ) , keys ) ; \n} \nkeys . add ( entry . getKey ( ) ) ; \n} \nreturn reverseMap ; \n} ", "end_by": "end_token"}
{"task_id": 165, "raw_nl": "Decode base64 string to bytes", "signature": "public byte[] base64decode(String base64string)", "code": "public byte [ ] base64decode ( String base64string ) { \nif ( base64string . length ( ) < 1 ) { \nreturn null ; \n} \nreturn Base64 . getDecoder ( ) . decode ( base64string ) ; \n} ", "end_by": "end_token"}
{"task_id": 166, "raw_nl": "\u901a\u8fc7\u53cd\u5c04\u4e3a\u5bf9\u8c61\u7684\u5bf9\u5e94\u5b57\u6bb5\u6ce8\u5165\u503c", "signature": "public <T> T initByReflect(String name, String value, T t)", "code": "public < T > T initByReflect ( String name , String value , T t ) { \ntry { \nClass < ? > clazz = t . getClass ( ) ; \nField [ ] fields = clazz . getDeclaredFields ( ) ; \nfor ( Field field : fields ) { \nif ( field . getName ( ) . equals ( name ) ) { \nfield . setAccessible ( true ) ; \nfield . set ( t , value ) ; \n} \n} \n} catch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nreturn t ; \n} ", "end_by": "end_token"}
{"task_id": 167, "raw_nl": "\u5c06\u6570\u7ec4\u8f6c\u4e3a List", "signature": "public <T> List<T> array2List(T[] array)", "code": "public < T > List < T > array2List ( T [ ] array ) { \nList < T > list = new ArrayList < > ( array . length ) ; \nCollections . addAll ( list , array ) ; \nreturn list ; \n} ", "end_by": "end_token"}
{"task_id": 168, "raw_nl": "\u83b7\u53d6\u8fc7\u53bb7\u5929\u7684\u65f6\u671f(\u5305\u62ec\u4eca\u5929)\uff0c\u683c\u5f0f\u4e3ayymmdd", "signature": "public List<String> getWeekDate()", "code": "public List < String > getWeekDate ( ) { \nList < String > list = new ArrayList < > ( ) ; \nfor ( int i = 0 ; i < 7 ; i ++ ) { \nlist . add ( getShortDate ( ) ) ; \n} \nreturn list ; \n} ", "end_by": "end_token"}
{"task_id": 169, "raw_nl": "Returns the total number of bytes remaining in the buffer array.", "signature": "public long remaining(ByteBuffer[] buffers)", "code": "public long remaining ( ByteBuffer [ ] buffers ) { \nlong result = 0 ; \nfor ( ByteBuffer buffer : buffers ) { \nresult += buffer . remaining ( ) ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 170, "raw_nl": "\u8fd4\u56dey\u5e74m\u6708d\u65e5\u5bf9\u5e94\u7684\u519c\u5386.\u8fd4\u56de\u683c\u5f0f\u4e3a\u67d0\u5e74\u67d0\u6708\u67d0\u65e5 ?", "signature": "public String getLunarDate(int year_log, int month_log, int day_log)", "code": "public String getLunarDate ( int year_log , int month_log , int day_log ) { \nString message = \"\" ; \n// \u4f20\u5165\u7684\u5e74\u3001\u6708\u3001\u65e5\u4e0d\u5408\u6cd5\u76f4\u63a5\u8fd4\u56de\nif ( year_log < 0 || year_log > 20 || month_log < 1 || month_log > 12 || day_log < 1 || day_log > 31 ) { \nreturn message ; \n} \n// \u8f6c\u6362\u62101\u53f7\nint year = year_log ; \nint month = month_log ; \nint day = day_log ; \nif ( month > 12 ) { \nmonth = month % 12 ; \nyear = year + 1 ; \n} \nif ( day > 31 ) { \nday = day % 31 ; \nmonth = month + 1 ; \n} \n// \u5e74\nString strYear = \"\" ; \n// \u6708\nString strMonth = \"\" ; \n// \u65e5\nString strDay = \"\" ; \nif ( year > 0 ) { \nstrYear = \" \" + ( \"\" + year ) ; \n} \nif ( month > 0 ) { \nstrMonth = \" \" + ( \"\" + month ) ; \n} \nif ( day > 0 ) { \nstrDay = \" \" + ( \"\" + day ) ; \n} \n// \u8f6c\u6362\u6210\u519c\u5386\nString myLunarString = \"\" ; \nmyLunarString = strYear + \"\u5e74\" + strMonth + \"\u6708\" + strDay + \"\u65e5\" ; \nreturn myLunarString ; \n} ", "end_by": "end_token"}
{"task_id": 171, "raw_nl": "\u53bb\u6389\u6d6e\u70b9\u6570\u591a\u4f59\u76840", "signature": "public String rvZeroAndDot(String s)", "code": "public String rvZeroAndDot ( String s ) { \nif ( s . isEmpty ( ) ) { \nreturn \"0\" ; \n} \nif ( s . indexOf ( \".\" ) > 0 ) { \ns = s . replaceAll ( \"0+?$\" , \"\" ) ; \n// \u5982\u6700\u540e\u4e00\u4f4d\u662f.\u5219\u53bb\u6389\ns = s . replaceAll ( \"[.]$\" , \"\" ) ; \n} \nreturn s ; \n} ", "end_by": "end_token"}
{"task_id": 172, "raw_nl": "\u5341\u8fdb\u5236\u6574\u578b\u6570\u503c\u51cf\u6cd5\uff0c\u5b57\u7b26\u4e32\u8868\u793a\u6bcf\u4e00\u4e2a\u6570", "signature": "public String bigDecimalSubtract(String str, String str1)", "code": "public String bigDecimalSubtract ( String str , String str1 ) { \nBigDecimal bd = new BigDecimal ( str ) ; \nBigDecimal bd1 = new BigDecimal ( str1 ) ; \nreturn rvZeroAndDot ( bd . subtract ( bd1 ) . toPlainString ( ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 173, "raw_nl": "Get the extension of a file. Return a null string if there is no extension.", "signature": "public String getFileExtension(File file)", "code": "public String getFileExtension ( File file ) { \nString filename = file . getName ( ) ; \nint i = filename . lastIndexOf ( '.' ) ; \nif ( i > 0 && i < filename . length ( ) -1 ) { \nreturn filename . substring ( i + 1 ) . toLowerCase ( ) ; \n} else { \nreturn null ; \n} \n} ", "end_by": "end_token"}
{"task_id": 174, "raw_nl": "\u5224\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\u662f\u4e0d\u662f\u6574\u6570", "signature": "public boolean isInteger(String numberString)", "code": "public boolean isInteger ( String numberString ) { \ntry { \nInteger . parseInt ( numberString ) ; \nreturn true ; \n} catch ( NumberFormatException ex ) { \nreturn false ; \n} \n} ", "end_by": "end_token"}
{"task_id": 176, "raw_nl": "Returns true if the bit at the given position is 1 and false otherwise.", "signature": "public boolean getBinaryState(int position)", "code": "public boolean getBinaryState ( int position ) { \nif ( position < 1 || position > 32 ) { \nthrow new IllegalArgumentException ( \"Position out of bound. Should be between 1 and 32.\" ) ; \n} \nreturn ( ( ( value >> ( position -1 ) ) & 0x01 ) == 0x01 ) ; \n} ", "end_by": "end_token"}
{"task_id": 177, "raw_nl": "\u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u7684ID", "signature": "public String getProcessId()", "code": "public String getProcessId ( ) { \nif ( ! TextUtils . isEmpty ( mProcessId ) ) { \nreturn mProcessId ; \n} \nif ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . P ) { \nString processId = getProcessIdPreP ( ) ; \nif ( ! TextUtils . isEmpty ( processId ) ) { \nreturn processId ; \n} \n} \nreturn getProcessIdPreQ ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 178, "raw_nl": "Handles comparison between version numbers (the right way(TM))\uff0cbigger return 1 \uff0csmaller return -1 and equals return 0. Examples of version strings: 1.6.7, 1.2_b10", "signature": "public int versionCompare(String v1, String v2)", "code": "public int versionCompare ( String v1 , String v2 ) { \nString [ ] v1Parts = v1 . split ( \"\\\\.\" ) ; \nString [ ] v2Parts = v2 . split ( \"\\\\.\" ) ; \nint i = 0 ; \nwhile ( i < v1Parts . length && i < v2Parts . length && v1Parts [ i ] . equals ( v2Parts [ i ] ) ) { \ni ++ ; \n} \nif ( i < v1Parts . length && i < v2Parts . length ) { \nreturn Integer . valueOf ( v1Parts [ i ] ) . compareTo ( Integer . valueOf ( v2Parts [ i ] ) ) ; \n} \nreturn Integer . valueOf ( v1Parts [ i ] ) . compareTo ( Integer . valueOf ( v2Parts [ i ] ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 179, "raw_nl": "\u5728map\u4e2d\uff0c\u5982\u679ckey\u5b58\u5728,\u5219value\u76f8\u52a0\uff1b\u5982\u679ckey \u4e0d\u5b58\u5728\uff0c\u589e\u52a0\u65b0\u7684key\uff0cvalue", "signature": "public Long incrBy(Map<String,Long> valMap,String key, Long integer)", "code": "public Long incrBy ( Map < String , Long > valMap , String key , Long integer ) { \nif ( valMap . containsKey ( key ) ) { \nreturn valMap . get ( key ) + integer ; \n} \nreturn valMap . put ( key , integer ) ; \n} ", "end_by": "end_token"}
{"task_id": 180, "raw_nl": "Check if a string is binary, which is composed of 0/1, and string length is multiple of 8.", "signature": "public boolean isBin(String bin)", "code": "public boolean isBin ( String bin ) { \nif ( bin == null || bin . length ( ) % 8 != 0 ) { \nreturn false ; \n} \nfor ( int i = 0 ; i < bin . length ( ) ; i += 8 ) { \nif ( ! isBinNibble ( bin . substring ( i , i + 8 ) ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 181, "raw_nl": "\u901a\u8fc7\u53cd\u5c04, \u83b7\u5f97Class\u5b9a\u4e49\u4e2d\u58f0\u660e\u7684\u6cdb\u578b\u53c2\u6570\u7684\u7c7b\u578b. \u5982\u65e0\u6cd5\u627e\u5230, \u8fd4\u56deObject.class.", "signature": "public Class getClassGenricType(Class clazz)", "code": "public Class getClassGenricType ( Class clazz ) { \nType genType = clazz . getGenericSuperclass ( ) ; \nif ( ! ( genType instanceof ParameterizedType ) ) { \nlogger . warn ( clazz . getSimpleName ( ) + \"'s superclass not ParameterizedType\" ) ; \nreturn Object . class ; \n} \nType [ ] params = ( ( ParameterizedType ) genType ) . getActualTypeArguments ( ) ; \nif ( params . length != 1 ) { \nlogger . warn ( clazz . getSimpleName ( ) + \" not only one parameter\" ) ; \nreturn Object . class ; \n} \nif ( ! ( params [ 0 ] instanceof Class ) ) { \nlogger . warn ( clazz . getSimpleName ( ) + \" not only class\" ) ; \nreturn Object . class ; \n} \nreturn ( Class ) params [ 0 ] ; \n} ", "end_by": "end_token"}
{"task_id": 182, "raw_nl": "\u6ee4\u6389\u8bcd\u4e32\u4e2d\u7684\u7a7a\u683c\u3001\u6807\u70b9\u7b26\u53f7", "signature": "public String[] filter(String[] word_list)", "code": "public String [ ] filter ( String [ ] word_list ) { \nList < String > results = new ArrayList < String > ( ) ; \nfor ( String w : word_list ) { \nif ( ! FILTER_CHARS . contains ( w ) ) { \nresults . add ( w . toLowerCase ( ) ) ; \n} \n} \nreturn results . toArray ( new String [ results . size ( ) ] ) ; \n} ", "end_by": "end_token"}
{"task_id": 183, "raw_nl": "BigDecimal\u52a0\u6cd5\u8fd0\u7b97", "signature": "public BigDecimal add(BigDecimal aVal, BigDecimal bVal)", "code": "public BigDecimal add ( BigDecimal aVal , BigDecimal bVal ) { \naVal = aVal == null ? BigDecimal . ZERO : aVal ; \nbVal = bVal == null ? BigDecimal . ZERO : bVal ; \nreturn aVal . add ( bVal ) ; \n} ", "end_by": "end_token"}
{"task_id": 186, "raw_nl": "Returns whether or no the JDK version is 1.7u40 and above.", "signature": "public boolean isJdk7u40Above()", "code": "public boolean isJdk7u40Above ( ) { \ncheckJdkVersion ( ) ; \nreturn _currentVersion . compareVersion ( 1.7 , 0 , 40 ) >= 0 ; \n} ", "end_by": "end_token"}
