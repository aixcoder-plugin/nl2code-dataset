{"task_id": 0, "raw_nl": "Take a collection of Strings and return a combined string as a comma separated list with 'and' between the final pair. For example: [a, b, c] to \"a, b and c\".", "signature": "public String collectionToCommaDelimitedString(List<String> coll)", "line_num": 259, "code": "{ \nif ( coll == null || coll . size ( ) == 0 ) { \nreturn \"\" ; \n} \nStringBuilder sb = new StringBuilder ( ) ; \nIterator < String > it = coll . iterator ( ) ; \nwhile ( it . hasNext ( ) ) { \nsb . append ( it . next ( ) ) ; \nif ( it . hasNext ( ) ) { \nsb . append ( \", \" ) ; \n} \n} \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 1, "raw_nl": "Creates a padding string of a certain length", "signature": "public String createPadding(int length, char padChar)", "line_num": 322, "code": "{ \nStringBuffer sb = new StringBuffer ( ) ; \nfor ( int i = 0 ; i < length ; i ++ ) { \nsb . append ( padChar ) ; \n} \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 2, "raw_nl": "Create and returns a HttpURLConnection connection to a webpage", "signature": "public HttpURLConnection createHttpConnection(URL url, int connectTimeout, Map<String, String> requestProperties)", "line_num": 35, "code": "throws IOException { \nHttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; \nconnection . setConnectTimeout ( connectTimeout ) ; \nconnection . setReadTimeout ( connectTimeout ) ; \nconnection . setRequestMethod ( \"POST\" ) ; \nconnection . setRequestProperty ( \"Content-Type\" , \"application/x-www-form-urlencoded\" ) ; \nconnection . setRequestProperty ( \"Content-Length\" , \"0\" ) ; \nconnection . setDoOutput ( true ) ; \nconnection . setDoInput ( true ) ; \nconnection . setUseCaches ( false ) ; \nconnection . setInstanceFollowRedirects ( true ) ; \nconnection . setRequestProperty ( \"Content-Language\" , \"en-US\" ) ; \nif ( requestProperties != null ) { \nfor ( Map . Entry < String , String > entry : requestProperties . entrySet ( ) ) { \nconnection . setRequestProperty ( entry . getKey ( ) , entry . getValue ( ) ) ; \n} \n} \nreturn connection ; \n} ", "end_by": "end_token"}
{"task_id": 3, "raw_nl": "Write content to the file. If file does not exist, it will create one.", "signature": "public void writeToFile(String content, String fileName)", "line_num": 344, "code": "throws IOException { \nif ( fileName == null ) { \nthrow new IllegalArgumentException ( \"File name can not be null\" ) ; \n} \nif ( fileName . isEmpty ( ) ) { \nthrow new IllegalArgumentException ( \"File name can not be empty\" ) ; \n} \nif ( content == null ) { \nthrow new IllegalArgumentException ( \"File content can not be null\" ) ; \n} \nif ( content . isEmpty ( ) ) { \nthrow new IllegalArgumentException ( \"File content can not be empty\" ) ; \n} \nFile file = new File ( fileName ) ; \nif ( ! file . exists ( ) ) { \nfile . createNewFile ( ) ; \n} \nFileWriter fileWriter = new FileWriter ( file ) ; \nfileWriter . write ( content ) ; \nfileWriter . close ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 4, "raw_nl": "Close Reader. If object is null it is ignored", "signature": "public void close(Reader reader)", "line_num": 272, "code": "{ \nif ( reader != null ) { \ntry { \nreader . close ( ) ; \n} catch ( IOException e ) { \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 5, "raw_nl": "max() that works on three integers. Like many of the other max() functions in this class", "signature": "public float max(float a, float b, float c) ", "line_num": 114, "code": "{ \nfloat ma = a > b ? a : b ; \nfloat mb = b > c ? b : c ; \nreturn ma > mb ? ma : mb ; \n} ", "end_by": "end_token"}
{"task_id": 6, "raw_nl": "put a short value into a byte array with specific offset", "signature": "public void putShort(byte[] data, short value, int offset)", "line_num": 95, "code": "{ \ndata [ offset ] = ( byte ) ( ( value >>> 8 ) & 0xFF ) ; \ndata [ offset + 1 ] = ( byte ) ( ( value ) & 0xFF ) ; \n} ", "end_by": "end_token"}
{"task_id": 7, "raw_nl": "从 http 服务拉取配置文件并解析为Properties 对象", "signature": "public Properties getProperties(String url)", "line_num": 250, "code": "{ \nProperties properties = new Properties ( ) ; \ntry { \nproperties . load ( new URL ( url ) . openStream ( ) ) ; \n} catch ( IOException e ) { \ne . printStackTrace ( ) ; \n} \nreturn properties ; \n} ", "end_by": "end_token"}
{"task_id": 8, "raw_nl": "给一个数组，找出最大值并且返回。", "signature": "public int findMaxNumber(int[] nums)", "line_num": 253, "code": "{ \nif ( nums == null || nums . length == 0 ) { \nreturn 0 ; \n} \nint maxNumber = nums [ 0 ] ; \nfor ( int i = 1 ; i < nums . length ; i ++ ) { \nif ( nums [ i ] > maxNumber ) { \nmaxNumber = nums [ i ] ; \n} \n} \nreturn maxNumber ; \n} ", "end_by": "end_token"}
{"task_id": 9, "raw_nl": "将 Date 类型转为时间字符串，格式为 format", "signature": "public String date2String(final Date date, final DateFormat format)", "line_num": 366, "code": "{ \nif ( format != null ) { \nreturn format . format ( date ) ; \n} else { \nreturn EMPTY ; \n} \n} ", "end_by": "end_token"}
{"task_id": 10, "raw_nl": "Looks through the backups directory and assembles a list of all json backup files found. ", "signature": "public List<String> getBackupFiles(String dir)", "line_num": 103, "code": "{ \nList < String > list = new ArrayList < String > ( ) ; \nFile [ ] files = new File ( dir ) . listFiles ( ) ; \nif ( files != null ) { \nfor ( File file : files ) { \nif ( file . getName ( ) . endsWith ( \".json\" ) ) { \nlist . add ( file . getName ( ) ) ; \n} \n} \n} \nreturn list ; \n} ", "end_by": "end_token"}
{"task_id": 11, "raw_nl": "Rearranges the elements of the specified subarray in random order.", "signature": "public void shuffle(int[] array)", "line_num": 306, "code": "{ \nif ( array == null ) \nthrow new NullPointerException ( \"argument array is null\" ) ; \nint n = array . length ; \nfor ( int i = 0 ; i < n ; i ++ ) { \n// between i and n-1\nint r = i + uniform ( n - i ) ; \nint temp = array [ i ] ; \narray [ i ] = array [ r ] ; \narray [ r ] = temp ; \n} \n} ", "end_by": "end_token"}
{"task_id": 12, "raw_nl": "Retrieves the value by specified int index of the given List.", "signature": "public String getValue(List<String> list, int index)", "line_num": 11, "code": "{ \nif ( list == null || index < 0 || index >= list . size ( ) ) { \nreturn null ; \n} \nreturn list . get ( index ) ; \n} ", "end_by": "end_token"}
{"task_id": 13, "raw_nl": "Returns a string, consisting of given length random char from given alphabet. ", "signature": "public String randomString(int length, String alphabet)", "line_num": 263, "code": "{ \nif ( alphabet == null || alphabet . length ( ) == 0 ) { \nthrow new IllegalArgumentException ( \"Alphabet must not be null or empty.\" ) ; \n} \nif ( length < 0 ) { \nthrow new IllegalArgumentException ( \"Length must not be negative.\" ) ; \n} \nif ( length > alphabet . length ( ) ) { \nthrow new IllegalArgumentException ( \"Length must not exceed alphabet length.\" ) ; \n} \nStringBuilder sb = new StringBuilder ( length ) ; \nfor ( int i = 0 ; i < length ; i ++ ) { \nsb . append ( alphabet . charAt ( nextInt ( alphabet . length ( ) ) ) ) ; \n} \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 14, "raw_nl": "用1到n随机初始化二维数组", "signature": "public void init(int[][] arr, int n) ", "line_num": 286, "code": "{ \nif ( arr == null || arr . length == 0 || arr [ 0 ] . length == 0 ) { \nreturn ; \n} \nint [ ] [ ] dp = new int [ n ] [ n ] ; \nfor ( int i = 0 ; i < n ; i ++ ) { \nArrays . fill ( dp [ i ] , -1 ) ; \n} \nfor ( int i = 0 ; i < arr . length ; i ++ ) { \nfor ( int j = 0 ; j < arr [ 0 ] . length ; j ++ ) { \nif ( arr [ i ] [ j ] != -1 ) { \ndp [ i ] [ j ] = arr [ i ] [ j ] ; \n} \n} \n} \nfor ( int i = 0 ; i < n ; i ++ ) { \nfor ( int j = 0 ; j < n ; j ++ ) { \nif ( dp [ i ] [ j ] != -1 ) { \narr [ i ] [ j ] = dp [ i ] [ j ] ; \n} \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 15, "raw_nl": "Copy a file from source path to destination path", "signature": "public void copyFile(String sourcePath, String destPath)", "line_num": 402, "code": "throws IOException { \nif ( ! sourcePath . endsWith ( \"/\" ) ) { \nsourcePath += \"/\" ; \n} \nif ( ! destPath . endsWith ( \"/\" ) ) { \ndestPath += \"/\" ; \n} \nif ( ! sourcePath . startsWith ( destPath ) ) { \nthrow new IOException ( \"source does not exist or is not a file\" ) ; \n} \nFile sourceFile = new File ( sourcePath ) ; \nif ( sourceFile . exists ( ) ) { \nsourceFile . delete ( ) ; \n} \nif ( sourceFile . isDirectory ( ) ) { \nString [ ] listFile = sourceFile . list ( ) ; \nif ( listFile != null ) { \nfor ( int i = 0 ; i < listFile . length ; i ++ ) { \nString destSubPath = destPath + listFile [ i ] ; \nString sourceSubPath = sourcePath + listFile [ i ] ; \ncopyFile ( sourceSubPath , destSubPath ) ; \n} \n} \n} else { \nBufferedInputStream bis = null ; \nBufferedOutputStream bos = null ; \ntry { \nbyte [ ] buf = new byte [ 1024 ] ; \nint bytesRead ; \nbis = new BufferedInputStream ( new FileInputStream ( sourceFile ) ) ; \nbos = new BufferedOutputStream ( new FileOutputStream ( destPath ) ) ; \nwhile ( ( bytesRead = bis . read ( buf ) ) != -1 ) { \nbos . write ( buf , 0 , bytesRead ) ; \n} \n} catch ( IOException e ) { \nthrow e ; \n} finally { \nif ( bis != null ) { \nbis . close ( ) ; \n} \nif ( bos != null ) { \nbos . close ( ) ; \n} \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 16, "raw_nl": "Get a hashCode for the real vector. All NaN values have the same hash code.", "signature": "public int hashCode(double[] vector)", "line_num": 52, "code": "{ \nif ( isNaN ( vector ) ) { \nreturn 9 ; \n} \nint h = 1 ; \nfor ( double aVector : vector ) { \nh = 31 * h + ( int ) ( aVector + 0.5 ) ; \n} \nreturn h ; \n} ", "end_by": "end_token"}
{"task_id": 17, "raw_nl": "Parses character set name to Charset object", "signature": "public Charset charsetForName(String charsetName)", "line_num": 311, "code": "{ \nif ( charsetName == null ) { \nreturn null ; \n} \ntry { \nreturn Charset . forName ( charsetName ) ; \n} catch ( Exception e ) { \nreturn null ; \n} \n} ", "end_by": "end_token"}
{"task_id": 18, "raw_nl": "Reads up to len bytes of data from this input stream into an array of bytes", "signature": "public byte[] readBytes(java.io.InputStream in, int len)", "line_num": 24, "code": "throws java . io . IOException { \nif ( in == null ) \nreturn null ; \nint i = 0 ; \nint available = available ( ) ; \nif ( available < len ) { \nlen = available ; \n} \nbyte [ ] buf = new byte [ len ] ; \nif ( available > 0 ) { \ni = in . read ( buf , 0 , available ) ; \nif ( i > 0 ) { \nthis . count += i ; \n} \n} \nreturn buf ; \n} ", "end_by": "end_token"}
{"task_id": 19, "raw_nl": "Parses query string to Map from an url.", "signature": "public Map<String, String> parseQueryString(String queryString)", "line_num": 307, "code": "{ \nMap < String , String > map = new HashMap < > ( ) ; \nif ( queryString != null ) { \nString [ ] parameters = queryString . split ( \"&\" ) ; \nfor ( String parameter : parameters ) { \nString [ ] keyValue = parameter . split ( \"=\" ) ; \nmap . put ( keyValue [ 0 ] , keyValue . length > 1 ? keyValue [ 1 ] : null ) ; \n} \n} \nreturn map ; \n} ", "end_by": "end_token"}
{"task_id": 20, "raw_nl": "Returns the value of an array by index, or null if the array has no value at that index.", "signature": "public Object get(Object[] array, int index)", "line_num": 320, "code": "{ \nif ( array == null ) { \nreturn null ; \n} \nObject value = array [ index ] ; \nif ( value == null ) { \nvalue = JSONObject . NULL ; \n} \nreturn value ; \n} ", "end_by": "end_token"}
{"task_id": 21, "raw_nl": "Set the additional (undeclared) property with the specified name and value. If the property does not already exist, create it otherwise replace it.", "signature": "public void putAdditionalProperty(String key, Object value, Map<String, Object> additionalProperties)", "line_num": 34, "code": "{ \nif ( value instanceof JsonElement ) { \nvalue = ( ( JsonElement ) value ) . getAsJsonObject ( ) ; \n} \nif ( additionalProperties == null ) { \nadditionalProperties = new HashMap < String , Object > ( ) ; \n} \nadditionalProperties . put ( key , value ) ; \n} ", "end_by": "end_token"}
{"task_id": 22, "raw_nl": "Read the base64 encoded image data from a JPEG image.", "signature": "public String readImageData(String filename)", "line_num": 75, "code": "throws IOException { \nFileInputStream fis = new FileInputStream ( filename ) ; \nbyte [ ] data = new byte [ fis . available ( ) ] ; \nfis . read ( data ) ; \nfis . close ( ) ; \nreturn Base64 . encode ( data ) ; \n} ", "end_by": "end_token"}
{"task_id": 23, "raw_nl": "Returns the distance for the two given point", "signature": "public float distance(float x0, float y0, float x1, float y1)", "line_num": 54, "code": "{ \nfloat dx = x1 - x0 ; \nfloat dy = y1 - y0 ; \nreturn ( float ) Math . sqrt ( dx * dx + dy * dy ) ; \n} ", "end_by": "end_token"}
{"task_id": 24, "raw_nl": "Writes a collection of Strings to a File, overwriting any previous file contents. Each String is converted into a line in the File.", "signature": "public void writeFile(Collection<String> lines, File file)", "line_num": 69, "code": "throws IOException { \nif ( file == null ) { \nthrow new IOException ( \"File is null\" ) ; \n} \nif ( file . isDirectory ( ) ) { \nthrow new IOException ( \"File is a directory\" ) ; \n} \nif ( ! file . getParentFile ( ) . exists ( ) ) { \nfile . getParentFile ( ) . mkdirs ( ) ; \n} \nif ( ! file . exists ( ) ) { \nfile . createNewFile ( ) ; \n} \ntry ( FileWriter fw = new FileWriter ( file ) ) { \nfor ( String line : lines ) { \nfw . write ( line ) ; \nfw . write ( \"\\n\" ) ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 25, "raw_nl": "Generate a hex string for the specified bytes.", "signature": "public final String toHex(byte[] byteArr)", "line_num": 100, "code": "{ \nif ( byteArr == null ) \nreturn \"\" ; \nreturn toHex ( byteArr , byteArr . length ) ; \n} ", "end_by": "end_token"}
{"task_id": 26, "raw_nl": "获取相应文件filepath的input stream", "signature": "public java.io.InputStream getInputStream(String filepath)", "line_num": 7, "code": "{ \njava . io . InputStream is = null ; \ntry { \nis = new FileInputStream ( filepath ) ; \n} catch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \n} \nreturn is ; \n} ", "end_by": "end_token"}
{"task_id": 27, "raw_nl": "获取类上具有指定注解的接口的名称，如果有多个，则以第一个为准 找不到符合条件的接口则返回 clazz 类的名称", "signature": "public String getInterfaceName(Class<?> clazz, Class<? extends Annotation> annotation)", "line_num": 91, "code": "{ \nif ( clazz == null ) { \nreturn null ; \n} \nString interfaceName = null ; \nClass < ? > [ ] interfaces = clazz . getInterfaces ( ) ; \nif ( interfaces == null || interfaces . length == 0 ) { \nreturn interfaceName ; \n} \nfor ( Class < ? > itfc : interfaces ) { \nif ( itfc . isAnnotationPresent ( annotation ) ) { \ninterfaceName = itfc . getName ( ) ; \n} \n} \nif ( interfaceName == null || interfaceName . length ( ) == 0 ) { \nreturn interfaceName ; \n} \nreturn interfaceName ; \n} ", "end_by": "end_token"}
{"task_id": 28, "raw_nl": "Split the given sequence with the given delimiter and return list of values.", "signature": "public java.util.List<String> split(String sequence, String delimiter)", "line_num": 362, "code": "{ \njava . util . List < String > result = new ArrayList < String > ( ) ; \nint start = 0 ; \nint index = 0 ; \nwhile ( ( index = sequence . indexOf ( delimiter , start ) ) != -1 ) { \nresult . add ( sequence . substring ( start , index ) ) ; \nstart = index + delimiter . length ( ) ; \n} \nresult . add ( sequence . substring ( start ) ) ; \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 29, "raw_nl": "This returns the euclidean distance of two vectors sum(i=1,n) (q_i - p_i)^2", "signature": "public double euclideanDistance(double[] p, double[] q)", "line_num": 358, "code": "{ \ndouble distance = 0 ; \nfor ( int i = 0 ; i < p . length ; i ++ ) { \ndistance += Math . pow ( ( p [ i ] - q [ i ] ) , 2 ) ; \n} \nreturn Math . sqrt ( distance ) ; \n} ", "end_by": "end_token"}
{"task_id": 30, "raw_nl": "Returns the entry associated with the specified key in map.", "signature": "public <K,V> Map.Entry<K, V> getEntry(Map<K,V> map, K key)", "line_num": 78, "code": "{ \nif ( map == null || key == null ) { \nreturn null ; \n} \nint hash = hash ( key ) ; \nint i = indexFor ( hash , table . length ) ; \nfor ( Entry < K , V > e = table [ i ] ; e != null ; e = e . next ) { \nObject k ; \nif ( e . hash == hash && ( ( k = e . key ) == key || key . equals ( k ) ) ) { \nreturn e ; \n} \n} \nreturn null ; \n} ", "end_by": "end_token"}
{"task_id": 31, "raw_nl": "Returns the index of the first occurrence of the specified element in this list, returns -1 if the element is not found", "signature": "public int indexOf(int[] array, int element) ", "line_num": 281, "code": "{ \nif ( array == null ) { \nreturn -1 ; \n} \nfor ( int i = 0 ; i < array . length ; i ++ ) { \nif ( array [ i ] == element ) { \nreturn i ; \n} \n} \nreturn -1 ; \n} ", "end_by": "end_token"}
{"task_id": 32, "raw_nl": "Returns the minimum value in an array.", "signature": "public int min(int[] array)", "line_num": 32, "code": "{ \n// Validates input\nif ( array == null ) { \nthrow new IllegalArgumentException ( \"The Array must not be null\" ) ; \n} else if ( array . length == 0 ) { \nthrow new IllegalArgumentException ( \"Array cannot be empty.\" ) ; \n} \n// Finds and returns min\nint min = array [ 0 ] ; \nfor ( int j = 1 ; j < array . length ; j ++ ) { \nif ( array [ j ] < min ) { \nmin = array [ j ] ; \n} \n} \nreturn min ; \n} ", "end_by": "end_token"}
{"task_id": 33, "raw_nl": "Returns the sum of logarithms, which is Sum( Log(x[i]) ).", "signature": "public double logSum(double[] x)", "line_num": 317, "code": "{ \ndouble sum = 0.0 ; \nfor ( int i = 0 ; i < x . length ; i ++ ) { \nsum += Math . log ( x [ i ] ) ; \n} \nreturn sum ; \n} ", "end_by": "end_token"}
{"task_id": 34, "raw_nl": "Do a simple bubble sort to sort the server ids in ascending order.", "signature": "public void sortServers(int[] serverIds)", "line_num": 111, "code": "{ \nint size = serverIds . length ; \nint lowest ; \nfor ( int i = 0 ; i < size ; i ++ ) { \nlowest = i ; \nfor ( int j = i + 1 ; j < size ; j ++ ) { \nif ( serverIds [ j ] < serverIds [ lowest ] ) \nlowest = j ; \n} \nif ( lowest != i ) { \nint temp = serverIds [ i ] ; \nserverIds [ i ] = serverIds [ lowest ] ; \nserverIds [ lowest ] = temp ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 35, "raw_nl": "Ensure that an object reference passed as a parameter to the calling method is not null.", "signature": "public void ensureNotNull(Object obj)", "line_num": 243, "code": "{ \nif ( obj == null ) { \nthrow new IllegalArgumentException ( \"Object must not be null\" ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 36, "raw_nl": "Extract the filename from the given path.", "signature": "public String extractFileName(String path)", "line_num": 300, "code": "{ \nint lastSlashIndex = path . lastIndexOf ( '/' ) ; \nint lastDotIndex = path . lastIndexOf ( '.' ) ; \nif ( lastDotIndex > lastSlashIndex ) { \nlastSlashIndex = lastDotIndex ; \n} \nreturn path . substring ( lastSlashIndex + 1 ) ; \n} ", "end_by": "end_token"}
{"task_id": 37, "raw_nl": "Fill 1D matrix with random numbers.", "signature": "public void fillMatrix_1D(double[] m)", "line_num": 315, "code": "{ \nRandom r = new Random ( 2 ) ; \nfor ( int i = 0 ; i < m . length ; i ++ ) { \nm [ i ] = r . nextDouble ( ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 38, "raw_nl": "Find the occurence of the given key in the given array. Linear search, worst case running time is O(n).", "signature": "public int linearSearch(int[] arr, int key) ", "line_num": 334, "code": "{ \nfor ( int i = 0 ; i < arr . length ; i ++ ) { \nif ( arr [ i ] == key ) { \nreturn i ; \n} \n} \nreturn -1 ; \n} ", "end_by": "end_token"}
{"task_id": 39, "raw_nl": "Generate a not existing temporary file in specified dir.", "signature": "public String generateTempFile(String dir)", "line_num": 338, "code": "{ \nString fileName = generateTempFileName ( dir ) ; \nFile file = new File ( dir , fileName ) ; \nif ( ! file . exists ( ) ) { \ntry { \nfile . createNewFile ( ) ; \n} catch ( IOException e ) { \nthrow new RuntimeException ( \"Cannot create temporary file \" + fileName , e ) ; \n} \n} \nreturn file . getAbsolutePath ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 40, "raw_nl": "Get one character of index i from a given string buffer.", "signature": "public char getChar(StringBuffer sb, int i)", "line_num": 124, "code": "{ \nif ( i < 0 || i >= sb . length ( ) ) { \nthrow new RuntimeException ( \"StringIndexOutOfBoundsException\" ) ; \n} \nreturn sb . charAt ( i ) ; \n} ", "end_by": "end_token"}
{"task_id": 41, "raw_nl": "将map中所有的key转为大写", "signature": "public Map<String, Object> getAllUpperCase(Map<String, Object> map)", "line_num": 89, "code": "{ \nif ( map == null ) { \nreturn null ; \n} \nMap < String , Object > mapUpper = new HashMap < > ( ) ; \nfor ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { \nmapUpper . put ( toUpperCase ( entry . getKey ( ) ) , entry . getValue ( ) ) ; \n} \nreturn mapUpper ; \n} ", "end_by": "end_token"}
{"task_id": 42, "raw_nl": "得到距离当前时间前一年的时间 @Title: getLastYearDate", "signature": "public String getLastYearDate()", "line_num": 352, "code": "{ \nint year = Calendar . getInstance ( ) . get ( Calendar . YEAR ) ; \nreturn year + \"年前\" ; \n} ", "end_by": "end_token"}
{"task_id": 43, "raw_nl": "更新url中的参数(保证参数不重复)", "signature": "public String updateUrl(String url, String key, String value)", "line_num": 271, "code": "{ \nMap < String , String > map = new HashMap < > ( ) ; \nmap . put ( key , value ) ; \nreturn updateUrl ( url , map ) ; \n} ", "end_by": "end_token"}
{"task_id": 44, "raw_nl": "移除 map 中的 null 或者 空字符串", "signature": "public void removeNullValue(Map<String, Object> map)", "line_num": 249, "code": "{ \nSet < String > keySet = map . keySet ( ) ; \nfor ( String key : keySet ) { \nObject obj = map . get ( key ) ; \nif ( obj == null ) { \nmap . remove ( key ) ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 45, "raw_nl": "获取某个时间data的年份", "signature": "public int getYear(Date date)", "line_num": 368, "code": "{ \nCalendar calendar = Calendar . getInstance ( ) ; \ncalendar . setTime ( date ) ; \nreturn calendar . get ( Calendar . YEAR ) ; \n} ", "end_by": "end_token"}
{"task_id": 46, "raw_nl": "Element-by-element matrix multiplication in place, A = A*B ", "signature": "public void matrixMultiply(double[][] A, double[][] B)", "line_num": 371, "code": "throws Exception { \ncheckMatrixDimensions ( A , B ) ; \nfor ( int i = 0 ; i < m ; i ++ ) { \nfor ( int j = 0 ; j < n ; j ++ ) { \nA [ i ] [ j ] = A [ i ] [ j ] * B [ i ] [ j ] ; \n} \n} \n} ", "end_by": "end_token"}
{"task_id": 47, "raw_nl": "通过反射获取某个类的对象内所有的 public 成员变量, 包括该类的基类", "signature": "public List<Field> getFields(Class<?> clazz)", "line_num": 372, "code": "{ \nif ( null == clazz ) { \nreturn null ; \n} \nList < Field > fields = new ArrayList < Field > ( ) ; \nfor ( Field field : clazz . getFields ( ) ) { \nfields . add ( field ) ; \n} \nreturn fields ; \n} ", "end_by": "end_token"}
{"task_id": 48, "raw_nl": "Adds all of the elements in collection to the Set.", "signature": "public void addAll(Set<Integer> set, Collection<Integer> collection)", "line_num": 373, "code": "{ \nfor ( int i : collection ) { \nadd ( i ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 49, "raw_nl": "Helper function to convert a long number into a byte array (least significant byte first).", "signature": "public byte[] longToBytes(long x)", "line_num": 375, "code": "{ \nbyte [ ] b = new byte [ 8 ] ; \nfor ( int i = 0 ; i < 8 ; i ++ ) { \nb [ i ] = ( byte ) x ; \nx >>>= 8 ; \n} \nreturn b ; \n} ", "end_by": "end_token"}
{"task_id": 50, "raw_nl": "将byte数组转化为16进制字符串", "signature": "public String bytesToHexString(byte[] src)", "line_num": 379, "code": "{ \nStringBuilder stringBuilder = new StringBuilder ( \"\" ) ; \nif ( src == null || src . length <= 0 ) { \nreturn null ; \n} \nfor ( int i = 0 ; i < src . length ; i ++ ) { \nint v = src [ i ] & 0xFF ; \nString hv = Integer . toHexString ( v ) ; \nif ( hv . length ( ) < 2 ) { \nstringBuilder . append ( 0 ) ; \n} \nstringBuilder . append ( hv ) ; \n} \nreturn stringBuilder . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 51, "raw_nl": "Returns a hash code value for this bit array.", "signature": "public int hashCode(byte[] byteArr)", "line_num": 380, "code": "{ \nint hashCode = 0 ; \nfor ( int i = 0 ; i < repn . length ; i ++ ) hashCode = 31 * hashCode + repn [ i ] ; \nfor ( int i = 0 ; i < length ; i ++ ) hashCode = 31 * hashCode + ( byteArr [ i ] & 0xFF ) ; \nreturn hashCode ^ length ; \n} ", "end_by": "end_token"}
{"task_id": 52, "raw_nl": "Removes the entry with the specified key from this map if present.", "signature": "public void remove(Map<Integer, String> mapObj, Integer key)", "line_num": 381, "code": "{ \nif ( mapObj == null || key == null ) { \nreturn ; \n} \nmapObj . remove ( key ) ; \n} ", "end_by": "end_token"}
{"task_id": 53, "raw_nl": "Convert a primitive input array into its object array version (e.g. from int[] to Integer[]).", "signature": "public Integer[] toObjectArray(int[] array)", "line_num": 383, "code": "{ \nInteger [ ] result = new Integer [ array . length ] ; \nfor ( int i = 0 ; i < array . length ; i ++ ) { \nresult [ i ] = array [ i ] ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 54, "raw_nl": "Converting object to JSON string. If errors appears throw MeshinException and RuntimeException.", "signature": "public String toJson(Object object)", "line_num": 384, "code": "{ \ntry { \nreturn mapper . writeValueAsString ( object ) ; \n} catch ( JsonProcessingException e ) { \nthrow new RuntimeException ( \"Error converting object to JSON\" , e ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 55, "raw_nl": "判断字符串是否只含字母和数字", "signature": "public boolean isLetterOrDigit(String str)", "line_num": 386, "code": "{ \nString regex = \"^[a-zA-Z0-9]+$\" ; \nreturn str . matches ( regex ) ; \n} ", "end_by": "end_token"}
{"task_id": 56, "raw_nl": "判断是否只含字母", "signature": "public boolean isLetter(char c)", "line_num": 387, "code": "{ \nif ( c > 'z' || c < 'a' ) { \nreturn false ; \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 57, "raw_nl": "Join 2 path elements if path separator not present at the end of first path element，else return the first element.", "signature": "public String joinPath(String path1, String path2)", "line_num": 388, "code": "{ \nif ( path1 . endsWith ( \"/\" ) && path2 . startsWith ( \"/\" ) ) { \nreturn path1 + path2 . substring ( 1 ) ; \n} else if ( path1 . endsWith ( \"/\" ) ) { \nreturn path1 + path2 ; \n} else if ( path2 . startsWith ( \"/\" ) ) { \nreturn path1 + path2 ; \n} else { \nreturn path1 + \"/\" + path2 ; \n} \n} ", "end_by": "end_token"}
{"task_id": 58, "raw_nl": "Converts an int into an array of byte using the default (little endian, Lsb0) byte and bit ordering.", "signature": "public byte[] intToByteArray(int value)", "line_num": 389, "code": "{ \nbyte [ ] src = new byte [ 4 ] ; \nsrc [ 0 ] = ( byte ) ( value & 0xff ) ; \nsrc [ 1 ] = ( byte ) ( ( value >> 8 ) & 0xff ) ; \nsrc [ 2 ] = ( byte ) ( ( value >> 16 ) & 0xff ) ; \nsrc [ 3 ] = ( byte ) ( ( value >> 24 ) & 0xff ) ; \nreturn src ; \n} ", "end_by": "end_token"}
{"task_id": 60, "raw_nl": "convert byte array to a hex string", "signature": "public String bytesToHex(byte[] bytes)", "line_num": 393, "code": "{ \nStringBuilder sbuf = new StringBuilder ( ) ; \nfor ( int idx = 0 ; idx < bytes . length ; idx ++ ) { \nint intVal = bytes [ idx ] & 0xff ; \nif ( intVal < 0x10 ) \nsbuf . append ( \"0\" ) ; \nsbuf . append ( Integer . toHexString ( intVal ) . toUpperCase ( ) ) ; \n} \nreturn sbuf . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 62, "raw_nl": "Calculates combinatorial number C(n,m). ", "signature": "public int combinatorial(int n, int m)", "line_num": 397, "code": "{ \nint result = 1 ; \nint i = n ; \nint j = m ; \nwhile ( i > 0 || j > 0 ) { \nif ( i > 0 ) { \nresult *= i ; \ni -- ; \n} \nif ( j > 0 ) { \nresult *= j ; \nj -- ; \n} \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 63, "raw_nl": "检验用户名是否合法，只能包括a-z,A-Z,0-9和下划线_，不能以下划线结尾 用户名有最小长度和最大长度限制，比如用户名必须是4-20位", "signature": "public boolean checkUsername(String username)", "line_num": 398, "code": "{ \nif ( username . length ( ) > 20 ) { \nreturn false ; \n} \nif ( username . length ( ) < 4 || username . length ( ) > 10 ) { \nreturn false ; \n} \nif ( ! username . matches ( \"[a-zA-Z0-9_]+\" ) ) { \nreturn false ; \n} \nreturn true ; \n} ", "end_by": "end_token"}
{"task_id": 64, "raw_nl": "得到现在时间", "signature": "public String getStringToday(String format)", "line_num": 401, "code": "{ \nDate currentTime = new Date ( ) ; \nSimpleDateFormat formatter = new SimpleDateFormat ( format ) ; \nString dateString = formatter . format ( currentTime ) ; \nreturn dateString ; \n} ", "end_by": "end_token"}
{"task_id": 65, "raw_nl": "return the last day of the date's month of specified string value in format: yyyy-MM", "signature": "public Date getMonthLastDay(String dateString)", "line_num": 302, "code": "{ \nSimpleDateFormat simpleDateFormat = new SimpleDateFormat ( \"yyyy-MM\" ) ; \nDate date = null ; \ntry { \ndate = simpleDateFormat . parse ( dateString ) ; \n} catch ( Exception e ) { \ne . printStackTrace ( ) ; \n} \nCalendar calendar = Calendar . getInstance ( ) ; \nif ( date != null ) { \ncalendar . setTime ( date ) ; \n} \ncalendar . add ( Calendar . MONTH , 1 ) ; \ncalendar . add ( Calendar . DAY_OF_MONTH , -1 ) ; \nreturn calendar . getTime ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 66, "raw_nl": "Merges the given two lists to a new list, but eliminating duplicates elements.", "signature": "public <T> ArrayList<T> merge(ArrayList<T> list1, ArrayList<T> list2)", "line_num": 82, "code": "{ \nArrayList < T > result = new ArrayList < T > ( ) ; \n// Keep track of the range of elements that we need to add.\nint range1 = 0 ; \nint range2 = 0 ; \n// Iterate through the lists to be merged.\nwhile ( true ) { \n// Get the current range of elements that we are going to add.\nint currentRangeSize = range2 - range1 + 1 ; \nif ( currentRangeSize > 0 ) { \n// If currentRangeSize is 1, there are multiple ranges to merge.\nif ( currentRangeSize == 1 ) { \n// Add the next range to the result.\nresult . add ( list1 . get ( range1 ) ) ; \n} else { \n// Add the next range to the result.\nresult . add ( list1 . get ( range1 ) ) ; \n// Merge the ranges.\nint mergeRangeSize = currentRangeSize -1 ; \nfor ( int i = 0 ; i < mergeRangeSize ; i ++ ) { \nresult . add ( list1 . get ( range1 + 1 + i ) ) ; \n} \n} \n// Increment the ranges to be merged with the next range.\nrange1 += currentRangeSize ; \nrange2 = range1 ; \n} else { \n// There are no more ranges to merge. Add the current range to the result.\nresult . add ( list1 . get ( range1 ) ) ; \nbreak ; \n} \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 67, "raw_nl": "Multiplies the vector by the transpose of the given matrix.", "signature": "public double[] multiplyTranspose(double[] vector, double[][] matrix)", "line_num": 2, "code": "{ \ndouble [ ] result = new double [ vector . length ] ; \nfor ( int i = 0 ; i < vector . length ; i ++ ) { \nresult [ i ] = 0 ; \nfor ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { \nresult [ i ] += vector [ j ] * matrix [ i ] [ j ] ; \n} \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 68, "raw_nl": "Removes and returns last element in list, return null if empty.", "signature": "public String removeLast(ArrayList<String> list)", "line_num": 20, "code": "{ \nif ( list . size ( ) == 0 ) \nreturn null ; \nreturn list . remove ( list . size ( ) -1 ) ; \n} ", "end_by": "end_token"}
{"task_id": 69, "raw_nl": "Returns the largest value in linked list.", "signature": "public int getMax(LinkedList<Integer> list)", "line_num": 262, "code": "{ \nint max = list . getLast ( ) ; \nint temp = 0 ; \nwhile ( list . size ( ) > 1 ) { \ntemp = list . get ( list . size ( ) -2 ) ; \nlist . remove ( list . size ( ) -1 ) ; \nlist . add ( temp ) ; \n} \nreturn max ; \n} ", "end_by": "end_token"}
{"task_id": 70, "raw_nl": "Calculate the elapsed time between two times specified in milliseconds.", "signature": "public long elapsedTime(Calendar start, Calendar end)", "line_num": 364, "code": "{ \nif ( start == null || end == null ) { \nthrow new IllegalArgumentException ( \"The dates must not be null\" ) ; \n} \nlong startMs = start . getTimeInMillis ( ) ; \nlong endMs = end . getTimeInMillis ( ) ; \nreturn ( endMs - startMs ) ; \n} ", "end_by": "end_token"}
{"task_id": 71, "raw_nl": "Compute the CRC32 of an array of bytes.", "signature": "public long crc32(byte[] bytes)", "line_num": 318, "code": "{ \nCrc32 crc = new Crc32 ( ) ; \ncrc . update ( bytes ) ; \nreturn crc . getValue ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 72, "raw_nl": "Create an instance of a clazz using the current thread context ClassLoader.", "signature": "public <T> T newInstance(Class<T> clazz)", "line_num": 93, "code": "{ \ntry { \nreturn clazz . newInstance ( ) ; \n} catch ( InstantiationException e ) { \nthrow new RuntimeException ( e ) ; \n} catch ( IllegalAccessException e ) { \nthrow new RuntimeException ( e ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 73, "raw_nl": "Delete data from start until end index (end inclusive) of a object List.", "signature": "public <T> void delete(List<T> list, int start, int end) ", "line_num": 56, "code": "{ \nif ( list == null ) \nreturn ; \nif ( start < 0 || end < 0 || start > end || end > list . size ( ) ) \nreturn ; \nif ( start == end ) { \nlist . clear ( ) ; \nreturn ; \n} \nif ( end == list . size ( ) ) { \nint s = start ; \nstart = end -1 ; \nend = s ; \n} \nT [ ] arr = list . toArray ( ( T [ ] ) new Object [ list . size ( ) - ( end - start ) ] ) ; \nint i = 0 ; \nfor ( ; i < arr . length ; i ++ ) { \nif ( i >= start && i < end ) \narr [ i ] = arr [ i + 1 ] ; \n} \nlist . clear ( ) ; \nfor ( T t : arr ) list . add ( t ) ; \n} ", "end_by": "end_token"}
{"task_id": 74, "raw_nl": "Get the intersection point of two lines.", "signature": "public Point getIntersection(Line line1, Line line2)", "line_num": 67, "code": "\n// The line end points are the end points of the lines (or line ends are coincident).\nPoint p1 = line1 . getEndPoint ( ) ; \nPoint p2 = line2 . getEndPoint ( ) ; \n// If the line ends coincident, the intersection point is the end point of the line.\nif ( p1 . equals ( p2 ) ) { \nreturn p1 ; \n} \n// If the line ends on the same side as the line start, the intersection point is the line start.\nif ( p1 . getX ( ) == p2 . getX ( ) ) { \nif ( p1 . getY ( ) == p2 . getY ( ) ) { \nreturn p1 ; \n} else { \nreturn new Point ( p1 . getY ( ) , p1 . getX ( ) ) ; \n} \n} \n// If the line ends on the same side as the line end, the intersection point is the line end.\nif ( p1 . getY ( ) == p2 . getY ( ) ) { \nif ( p1 . getX ( ) == p2 . getX ( ) ) { \nreturn p1 ; \n} else { \n/ The intersection point is the line end.\nreturn new Point ( p2 . getX ( ) , p2 . getY ( ) ) ; \n} \n} \n// If the line ends in the same direction as the line start and the line end, the intersection point is the line start with the line end.\nif ( p1 . getX ( ) == p2 . getX ( ) && p1 . getY ( ) == p2 . getY ( ) ) { \nreturn p1 ; \n} \n// If the line ends in the same direction as the line start and the line end, the intersection point is the line end with the line start.\nif ( p1 . getX ( ) == p2 . getX ( ) && p1 . getY ( ) == p2 . getY ( ) ) { \nreturn p2 ; \n} \n// The intersection point is the end point of the line.\nreturn new Point ( p1 . getY ( ) , p1 . getX ( ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 75, "raw_nl": "Get the number of days for the given month in the given year.", "signature": "public int getDaysInMonth(int year, int month)", "line_num": 275, "code": "{ \nif ( month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 ) { \nreturn 31 ; \n} \nif ( month == 4 || month == 6 || month == 9 || month == 11 ) { \nreturn 30 ; \n} \nif ( month == 2 ) { \nif ( isLeapYear ( year ) ) { \nreturn 29 ; \n} else { \nreturn 28 ; \n} \n} \nreturn 0 ; \n} ", "end_by": "end_token"}
{"task_id": 76, "raw_nl": "得到filepath路径下第一层目录结构中所有的class文件", "signature": "public List<String> getClassFileNames(String filepath)", "line_num": 369, "code": "{ \nList < String > fileNames = new ArrayList < String > ( ) ; \nFile file = new File ( filepath ) ; \nif ( file . exists ( ) ) { \nfileNames = getClassFileNames ( file ) ; \n} \nreturn fileNames ; \n} ", "end_by": "end_token"}
{"task_id": 77, "raw_nl": "打开文件filename，并返回文件输入流", "signature": "public FileInputStream openFile(String filename)", "line_num": 328, "code": "{ \ntry { \nreturn new FileInputStream ( filename ) ; \n} catch ( FileNotFoundException e ) { \ne . printStackTrace ( ) ; \nreturn null ; \n} \n} ", "end_by": "end_token"}
{"task_id": 78, "raw_nl": "用str2替换字符串str中第一个出现的str1", "signature": "public String replaceFirst(String str, String str1, String str2) ", "line_num": 251, "code": "{ \nif ( str == null || str1 == null || str2 == null ) { \nreturn null ; \n} \nif ( str . indexOf ( str1 ) == -1 ) { \nreturn str ; \n} \nreturn str . substring ( 0 , str . indexOf ( str1 ) ) + str2 + str . substring ( str . indexOf ( str1 ) + str1 . length ( ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 79, "raw_nl": "Writes certain bytes from the specified byte array starting from an offset to this output stream.", "signature": "public void write(byte[] b, int off, int len, OutputStream outputStream)", "line_num": 116, "code": "throws IOException { \nif ( b == null ) { \nthrow new NullPointerException ( ) ; \n} else if ( ( off < 0 ) || ( off > b . length ) || ( len < 0 ) || ( ( off + len ) > b . length ) || ( ( off + len ) < 0 ) ) { \nthrow new IndexOutOfBoundsException ( ) ; \n} else if ( len == 0 ) { \nreturn ; \n} \nint newcount = count + len ; \nif ( newcount > buf . length ) { \nbuf = Utils . copyOf ( buf , Math . max ( buf . length << 1 , newcount ) ) ; \n} \nSystem . arraycopy ( b , off , buf , count , len ) ; \ncount = newcount ; \n} ", "end_by": "end_token"}
{"task_id": 80, "raw_nl": "随机生成[origin, bound)范围之内的一个int值", "signature": "public int randomInt(int origin, int bound)", "line_num": 265, "code": "{ \nif ( origin >= bound ) { \nthrow new IllegalArgumentException ( \"bound must be greater than origin\" ) ; \n} \nreturn ( int ) ( origin + ( ( bound - origin ) * Math . random ( ) ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 81, "raw_nl": "上传一个文件至指定路径pathname下", "signature": "public void uploadFile(String pathname, String filename)", "line_num": 376, "code": "throws Exception { \nFile file = new File ( pathname ) ; \nif ( ! file . exists ( ) ) { \nthrow new Exception ( \"文件不存在\" ) ; \n} \nFileInputStream fis = new FileInputStream ( file ) ; \nthis . client . setFileType ( FTPClient . BINARY_FILE_TYPE ) ; \nthis . client . storeFile ( filename , fis ) ; \nfis . close ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 82, "raw_nl": "Debug helper function that returns the diff of two property maps, only displaying the key that is different and in which map it exists compared to the other map,example:map:key1,key2 map2:key1,key2,key3", "signature": "public String diff(java.util.Map<String, String> map1, java.util.Map<String, String> map2) ", "line_num": 385, "code": "{ \nStringBuilder sb = new StringBuilder ( ) ; \nsb . append ( \"=== PropertyMap diff ===\\n\" ) ; \nsb . append ( \"PropertyMap map1:\\n\" ) ; \nsb . append ( map1 . toString ( ) ) ; \nsb . append ( \"PropertyMap map2:\\n\" ) ; \nsb . append ( map2 . toString ( ) ) ; \nsb . append ( \"\\n\" ) ; \nsb . append ( \"PropertyMap diff:\\n\" ) ; \nsb . append ( \"map1 size: \" + map1 . size ( ) + \"\\n\" ) ; \nsb . append ( \"map2 size: \" + map2 . size ( ) + \"\\n\" ) ; \nsb . append ( \"map1 keys: \" + map1 . keySet ( ) + \"\\n\" ) ; \nsb . append ( \"map2 keys: \" + map2 . keySet ( ) + \"\\n\" ) ; \nsb . append ( \"map1 values: \" + map1 . values ( ) + \"\\n\" ) ; \nsb . append ( \"map2 values: \" + map2 . values ( ) + \"\\n\" ) ; \nsb . append ( \"\\n\" ) ; \nreturn sb . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 83, "raw_nl": "Returns a new, immutable collection containing the names of all entities within the directory denoted by the current path", "signature": "public List<String> getFiles(String dir)", "line_num": 395, "code": "{ \nList < String > list = new ArrayList < String > ( ) ; \nFile file = new File ( dir ) ; \nif ( ! file . exists ( ) ) { \nreturn list ; \n} \nFile [ ] files = file . listFiles ( ) ; \nif ( files == null ) { \nreturn list ; \n} \nfor ( File f : files ) { \nif ( f . isFile ( ) ) { \nlist . add ( f . getName ( ) ) ; \n} \n} \nreturn list ; \n} ", "end_by": "end_token"}
{"task_id": 84, "raw_nl": "Rotate this a two-dimensional point around Y axis with the given angle in radians.", "signature": "public Point rotateY(double angle, Point point)", "line_num": 399, "code": "{ \ndouble x = point . x - this . x ; \ndouble y = point . y - this . y ; \ndouble cos = Math . cos ( angle ) ; \ndouble sin = Math . sin ( angle ) ; \nthis . x = x * cos - y * sin ; \nthis . y = x * sin + y * cos ; \nreturn this ; \n} ", "end_by": "end_token"}
{"task_id": 85, "raw_nl": "If the string passed in is not blank or null and did not end with the trailing value, then appended the trailing value to it and return the result ", "signature": "public String appendTrailing(String str, String trailing)", "line_num": 400, "code": "{ \nif ( str == null || str . isEmpty ( ) ) { \nreturn null ; \n} \nif ( isEmpty ( trailing ) ) { \nreturn trailing ; \n} \nif ( isEmpty ( ) ) { \nreturn str ; \n} \nif ( str . endsWith ( \"\\n\" ) ) { \nreturn str + trailing ; \n} \nif ( str . endsWith ( \"\\r\" ) ) { \nreturn str . concat ( trailing ) ; \n} \nreturn str + \"\\n\" + trailing ; \n} ", "end_by": "end_token"}
{"task_id": 86, "raw_nl": "Returns true if the collection contains an element for the key.", "signature": "public boolean containsKey(Collection<String> collection, String key)", "line_num": 126, "code": "{ \nfor ( String value : collection ) { \nif ( value . equals ( key ) ) { \nreturn true ; \n} \n} \nreturn false ; \n} ", "end_by": "end_token"}
{"task_id": 87, "raw_nl": "Returns true if the given object is an instance of the class or interface specified.", "signature": "public boolean isInstanceOf(Object object, Class<?> type)", "line_num": 106, "code": "{ \nif ( object == null ) { \nreturn false ; \n} \nif ( type . isInstance ( object ) ) { \nreturn true ; \n} \nif ( object instanceof String ) { \nreturn type . isAssignableFrom ( object . getClass ( ) ) ; \n} \nreturn false ; \n} ", "end_by": "end_token"}
{"task_id": 88, "raw_nl": "将16进制字符串转10进制", "signature": "public int hexStringToInt(String hexString)", "line_num": 23, "code": "{ \nint result = 0 ; \nint index = 0 ; \nint n = 0 ; \nint b = 0 ; \nfor ( int i = 0 ; i < hexString . length ( ) ; i ++ ) { \nindex = i % 2 ; \nn = Integer . valueOf ( hexString . substring ( i , i + 1 ) , 16 ) ; \nb = Integer . valueOf ( hexString . substring ( i + 1 , i + 2 ) , 16 ) ; \nresult += ( b << index * 4 ) ; \n} \nreturn result ; \n} ", "end_by": "end_token"}
{"task_id": 89, "raw_nl": "Add two integers, checking for overflow.", "signature": "public bool checkOverflow(int x, int y)", "line_num": 22, "code": "{ \nif ( x > y ) { \n// check for overflow\nif ( x < 0 ) \nreturn true ; \nelse \nreturn false ; \n} else { \n// check for overflow\nif ( y < 0 ) \nreturn true ; \nelse \nreturn false ; \n} \n} ", "end_by": "end_token"}
{"task_id": 90, "raw_nl": "Add the value to the HashSet given by map.get(key), creating a new HashSet if the HashSet is null", "signature": "public void addToSet(Map<String, HashSet<Integer>> map, String key, Integer value)", "line_num": 323, "code": "{ \nif ( map == null ) { \nreturn ; \n} \nif ( ! map . containsKey ( key ) ) { \nmap . put ( key , new HashSet < > ( ) ) ; \n} \nmap . get ( key ) . add ( value ) ; \n} ", "end_by": "end_token"}
{"task_id": 91, "raw_nl": "Calculate and return the average of the two values rounded DOWN.", "signature": "public int average(int a, int b)", "line_num": 336, "code": "{ \nint c = a + b - ( ( a & b ) << 1 ) ; \nif ( // uh oh\nc < 0 ) \nc += 0x1000000 ; \nreturn c ; \n} ", "end_by": "end_token"}
{"task_id": 92, "raw_nl": "Check if #MIN_VALUE <= value <= #MAX_VALUE and if not an IllegalArgumentException is thrown.", "signature": "public void checkRange(int value, int min, int max)", "line_num": 273, "code": "{ \nif ( ( value < min ) || ( value > max ) ) { \nthrow new IllegalArgumentException ( \"Value is out of range : \" + value ) ; \n} \n} ", "end_by": "end_token"}
{"task_id": 93, "raw_nl": "Check whether the String is a valid Java number", "signature": "public boolean isNumber(String str)", "line_num": 26, "code": "{ \nif ( StringUtils . isEmpty ( str ) ) { \nreturn false ; \n} \nchar [ ] chars = str . toCharArray ( ) ; \nint sz = chars . length ; \nboolean hasExp = false ; \nboolean hasDecPoint = false ; \nboolean allowSigns = false ; \nboolean foundDigit = false ; \n// deal with any possible sign up front\nint start = ( chars [ 0 ] == '-' ) ? 1 : 0 ; \nif ( sz > start + 1 ) { \nif ( chars [ start ] == '0' && chars [ start + 1 ] == 'x' ) { \nint i = start + 2 ; \nif ( i == sz ) { \nreturn false ; \n} \n// checking hex (it can't be anything else)\nfor ( ; i < chars . length ; i ++ ) { \nif ( ( chars [ i ] < '0' || chars [ i ] > '9' ) && ( chars [ i ] < 'a' || chars [ i ] > 'f' ) && ( chars [ i ] < 'A' || chars [ i ] > 'F' ) ) { \nreturn false ; \n} \n} \nreturn true ; \n} \n} \n// don't want to loop to the last char, check it afterwords\nsz -- ; \n// for type qualifiers\nint i = start ; \n// make a valid number (e.g. chars[0..5] = \"1234E\")\nwhile ( i < sz || ( i < sz + 1 && allowSigns && ! foundDigit ) ) { \nif ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { \nfoundDigit = true ; \nallowSigns = false ; \n} else if ( chars [ i ] == '.' ) { \nif ( hasDecPoint || hasExp ) { \n// two decimal points or dec in exponent\nreturn false ; \n} \nhasDecPoint = true ; \n} else if ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { \n// we've already taken care of hex.\nif ( hasExp ) { \n// two E's\nreturn false ; \n} \nif ( ! foundDigit ) { \nreturn false ; \n} \nhasExp = true ; \nallowSigns = true ; \n} else if ( chars [ i ] == '+' || chars [ i ] == '-' ) { \nif ( ! allowSigns ) { \nreturn false ; \n} \nallowSigns = false ; \n// we need a digit after the E\nfoundDigit = false ; \n} else { \nreturn false ; \n} \ni ++ ; \n} \nif ( i < chars . length ) { \nif ( chars [ i ] >= '0' && chars [ i ] <= '9' ) { \n// no type qualifier, OK\nreturn true ; \n} \nif ( chars [ i ] == 'e' || chars [ i ] == 'E' ) { \n// can't have an E at the last byte\nreturn false ; \n} \nif ( chars [ i ] == '.' ) { \nif ( hasDecPoint || hasExp ) { \n// two decimal points or dec in exponent\nreturn false ; \n} \n// single trailing decimal point after non-exponent is ok\nreturn foundDigit ; \n} \nif ( ! allowSigns && ( chars [ i ] == 'd' || chars [ i ] == 'D' || chars [ i ] == 'f' || chars [ i ] == 'F' ) ) { \nreturn foundDigit ; \n} \nif ( chars [ i ] == 'l' || chars [ i ] == 'L' ) { \n// not allowing L with an exponent or decimal point\nreturn foundDigit && ! hasExp && ! hasDecPoint ; \n} \n// last character is illegal\nreturn false ; \n} \n// found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\nreturn ", "end_by": "max_len"}
{"task_id": 94, "raw_nl": "Choose a pseudo-random element from the specified array.", "signature": "public int random(int[] array)", "line_num": 241, "code": "{ \nint index = random . nextInt ( array . length ) ; \nreturn array [ index ] ; \n} ", "end_by": "end_token"}
{"task_id": 95, "raw_nl": "Compare two java objects for equality.", "signature": "public boolean equals(Object o1, Object o2)", "line_num": 258, "code": "{ \nif ( o1 == o2 ) { \nreturn true ; \n} \nif ( ! ( o1 instanceof AbstractJcrNode ) || ! ( o2 instanceof AbstractJcrNode ) ) { \nreturn false ; \n} \nAbstractJcrNode n1 = ( AbstractJcrNode ) o1 ; \nAbstractJcrNode n2 = ( AbstractJcrNode ) o2 ; \nreturn n1 . getNodeName ( ) . equals ( n2 . getNodeName ( ) ) && n1 . getParent ( ) . equals ( n2 . getParent ( ) ) ; \n} ", "end_by": "end_token"}
{"task_id": 96, "raw_nl": "Compute the product of this matrix and the given column vector.", "signature": "public double[] product(double[] columnVector,double[][] matrix)", "line_num": 304, "code": "{ \nif ( columnVector . length != matrix . length ) { \nthrow new IllegalArgumentException ( \"vector length and matrix length do not match\" ) ; \n} \ndouble [ ] product = new double [ matrix [ 0 ] . length ] ; \nfor ( int i = 0 ; i < product . length ; i ++ ) { \nproduct [ i ] = 0 ; \nfor ( int j = 0 ; j < product . length ; j ++ ) { \nproduct [ i ] += matrix [ i ] [ j ] * columnVector [ j ] ; \n} \n} \nreturn product ; \n} ", "end_by": "end_token"}
{"task_id": 97, "raw_nl": "Concatenate two arrays of T type", "signature": "public <T> T[] concat(T[] a, T[] b)", "line_num": 77, "code": "{ \nT [ ] c = Arrays . copyOf ( a , a . length + b . length ) ; \nSystem . arraycopy ( b , 0 , c , a . length , b . length ) ; \nreturn c ; \n} ", "end_by": "end_token"}
{"task_id": 98, "raw_nl": "Convert the text '&' mnemonic string to text string. The '&' symbol is treated as the mnemonic pointer. The double \"&&\" symbols are treated as the single '&'. For example the string \"&Look && Feel\" is converted to \"Look & Feel\".", "signature": "public String convertMnemonicString(String text)", "line_num": 289, "code": "{ \nStringBuilder buf = new StringBuilder ( ) ; \nint prevIndex = 0 ; \nint nextIndex = text . indexOf ( '&' ) ; \nint len = text . length ( ) ; \nwhile ( nextIndex != -1 ) { \nString s = text . substring ( prevIndex , nextIndex ) ; \nbuf . append ( s ) ; \nnextIndex ++ ; \nif ( nextIndex != len && text . charAt ( nextIndex ) == '&' ) { \nbuf . append ( '&' ) ; \nnextIndex ++ ; \n} \nprevIndex = nextIndex ; \nnextIndex = text . indexOf ( '&' , nextIndex + 1 ) ; \n} \nbuf . append ( text . substring ( prevIndex , text . length ( ) ) ) ; \nreturn buf . toString ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 99, "raw_nl": "Convert a boolean value into a string.", "signature": "public String boolToString(boolean b)", "line_num": 268, "code": "{ \nif ( b ) { \nreturn \"true\" ; \n} else { \nreturn \"false\" ; \n} \n} ", "end_by": "end_token"}
{"task_id": 61, "raw_nl": "Print a float and then flush the output stream.", "signature": "public void print(float x,OutputStream out)", "line_num": 394, "code": "{ \nout . print ( x ) ; \nout . flush ( ) ; \n} ", "end_by": "end_token"}
{"task_id": 100, "raw_nl": "Convert an arbitrary text encoding to its canonical name.", "signature": "public String canonicalEncodingName(String encoding)", "line_num": 298, "code": "{ \nif ( encoding == null ) { \nreturn null ; \n} \ntry { \nreturn Charset . forName ( encoding ) . name ( ) ; \n} catch ( IllegalCharsetNameException icne ) { \nreturn encoding ; \n} catch ( UnsupportedCharsetException uce ) { \nreturn encoding ; \n} \n} ", "end_by": "end_token"}
{"task_id": 101, "raw_nl": "Create a copy of the Integer array.", "signature": "public int[] copy(int[] arr)", "line_num": 60, "code": "{ \nif ( arr == null ) { \nreturn null ; \n} \nint [ ] copy = new int [ arr . length ] ; \nfor ( int i = 0 ; i < arr . length ; i ++ ) { \ncopy [ i ] = arr [ i ] ; \n} \nreturn copy ; \n} ", "end_by": "end_token"}
{"task_id": 102, "raw_nl": "Returns the current number of entries in the map.", "signature": "public int size(Map<String, String> map)", "line_num": 404, "code": "{ \nint total = 0 ; \nfor ( Map . Entry < String , String > entry : map . entrySet ( ) ) { \ntotal += entry . getValue ( ) . length ( ) ; \n} \nreturn total ; \n} ", "end_by": "end_token"}
{"task_id": 103, "raw_nl": "Returns true if two doubles are considered equal. Tests if the absolute difference between the two doubles has a difference less then a given double (epsilon)Returns true if two doubles are considered equal. Tests if the absolute difference between the two doubles has a difference less then a given double (epsilon)", "signature": "public boolean equals(double a, double b, double epsilon)", "line_num": 405, "code": "{ \nif ( Math . abs ( a - b ) <= epsilon ) \nreturn true ; \nreturn false ; \n} ", "end_by": "end_token"}
